/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TinyLocal
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");
var path3 = __toESM(require("path"));
var fs3 = __toESM(require("fs"));

// i18n helper
const I18N = {
  en: {
    "settings.title": "Settings",
    "warning.binariesMissing": "Binaries not found: set paths in settings or install pngquant/mozjpeg.",
    "command.compressInNote": "Compress all images in note",
    "command.compressInFolder": "Compress all images in folder",
    "command.compressAll": "Compress all images in vault",
    "command.moveCompressed": "Move compressed files",
    "context.compressImage": "Compress image",
    "context.compressImagesInFolder": "Compress images in folder",
    "notice.cacheUpdated": "Cache updated",
    "notice.cacheCleared": "Cache cleared",
    "section.quality": "Compression quality",
    "section.paths": "Path settings",
    "section.automation": "Automation",
    "section.stats": "Statistics & cache",
    "section.move": "Move compressed files",
    "section.cacheBackups": "Cache backups",
    "section.system": "System",
    "binaries.available": "Available",
    "binaries.notFound": "Not found",
    "section.instructions": "Instructions",
    "quality.png.name": "PNG quality (min-max)",
    "quality.png.desc": "Quality range for PNG compression (65-80 by default)",
    "quality.jpeg.name": "JPEG quality",
    "quality.jpeg.desc": "JPEG compression quality (1-95)",
    "paths.pngquant.name": "Path to pngquant",
    "paths.pngquant.desc": "Full path to pngquant binary or leave empty for auto-detection",
    "paths.mozjpeg.name": "Path to mozjpeg",
    "paths.mozjpeg.desc": "Full path to mozjpeg binary or leave empty for auto-detection",
    "paths.allowedRoots.name": "Allowed roots",
    "paths.allowedRoots.desc": "Select folders where compression is allowed (empty = all paths)",
    "paths.allowedRoots.empty": "Not selected (compress everywhere)",
    "paths.allowedRoots.pill.remove": "Click to remove",
    "paths.allowedRoots.modal.placeholder": "Select a folder...",
    "paths.allowedRoots.clear": "Clear list",
    "paths.output.name": "Output folder",
    "paths.output.desc": "Folder name to store compressed files",
    "auto.newFiles.name": "Auto-compress new files",
    "auto.newFiles.desc": "Automatically compress new images when added to vault",
    "auto.bg.name": "Automatic background compression",
    "auto.bg.desc": "Automatically compress in background when you are inactive",
    "auto.bg.threshold.name": "Background compression threshold",
    "auto.bg.threshold.desc": "Number of uncompressed images to auto-start",
    "auto.retention.toggle.name": "Auto-delete image backups",
    "auto.retention.toggle.desc": "Delete image backups by retention period",
    "auto.retention.days.name": "Backups retention (days)",
    "auto.retention.days.desc": "Delete backups older than the specified number of days",
    "auto.move.toggle.name": "Enable auto-move of compressed files",
    "auto.move.toggle.desc": "Automatically move compressed files when threshold is reached",
    "auto.move.threshold.name": "Auto-move threshold (items)",
    "auto.move.threshold.desc": "How many files in 'Compressed' to trigger auto-move",
    "auto.cleanupGhosts.name": "Auto-clean ghost entries on start",
    "auto.cleanupGhosts.desc": "Automatically remove cache entries pointing to deleted files on startup",
    "stats.uncompressed.name": "Uncompressed images",
    "stats.uncompressed.ready": "images ready to compress",
    "stats.cache.name": "Cache entries",
    "stats.cache.entries": "entries",
    "stats.cache.size": "size",
    "stats.ghosts.name": "Ghost entries",
    "stats.ghosts.pointToMissing": "cache entries point to deleted files",
    "move.title": "Move compressed files",
    "move.ready": "compressed files are ready to move",
    "move.button": "Move",
    "move.noCompressedFolder": "Compressed folder not found",
    "move.noneToMove": "No compressed files to move",
    "move.noneWithOriginals": "No compressed files with originals in allowed roots",
    "backups.imagesFolder.name": "Image backups folder",
    "backups.imagesFolder.desc": "Open folder with backups of original/compressed images",
    "backups.imagesFolder.openButton": "Open image backups folder",
    "backups.imagesFolder.openError": "Failed to open image backups folder",
    "backups.cache.title": "Cache backups",
    "backups.pathLabel": "Path",
    "backups.foundLabel": "Backups found",
    "backups.cache.none": "No cache backups available",
    "backups.cache.restore": "Restore cache from backup",
    "backups.cache.available": "Available backups:",
    "backups.cache.selectPlaceholder": "-- Select backup --",
    "common.add": "Add",
    "common.refresh": "Refresh",
    "common.clearCache": "Clear cache",
    "common.refreshCache": "Refresh cache",
    "common.clearGhosts": "Clear ghosts",
    "common.clear": "Clear",
    "units.kb": "KB",
    "instructions.usageTitle": "Usage:",
    "instructions.notesTitle": "Notes:",
    "instructions.notes.saved": "Compressed files are saved in",
    "instructions.notes.originalUnchanged": "Original files are not modified",
    "instructions.notes.recompressionSkipped": "Re-compression is skipped thanks to cache"
    ,"progress.start": "Starting..."
    ,"progress.processing": "Processing"
    ,"progress.skippedAlready": "Skipped (already compressed)"
    ,"progress.skipped": "Skipped"
    ,"progress.compressed": "Compressed"
    ,"progress.error": "Error"
    ,"progress.completed": "Completed! Compressed"
    ,"folders.noneInVault": "No folders found in vault"
    ,"folderSelect.title": "Select a folder for image compression"
    ,"folderSelect.root": "Root folder"
    ,"folderSelect.select": "Select"
    ,"folderSelect.cancel": "Cancel"
    ,"instructions.action.rightClick": "Right-click an image →"
    ,"instructions.action.commandPalette": "Command Palette →"
    ,"savings.original": "Original"
    ,"savings.current": "Current"
    ,"savings.saved": "Saved"
    ,"tooltip.savings.header": "Space Savings Details"
    ,"tooltip.savings.original": "Original Size:"
    ,"tooltip.savings.current": "Current Size:"
    ,"tooltip.savings.saved": "Space Saved:"
    ,"tooltip.savings.filesProcessed": "Files Processed:"
  },
  ru: {
    "settings.title": "Настройки",
    "warning.binariesMissing": "Бинарники не найдены: укажите пути в настройках или установите pngquant/mozjpeg в систему.",
    "command.compressInNote": "Сжать все изображения в заметке",
    "command.compressInFolder": "Сжать все изображения в папке",
    "command.compressAll": "Сжать все изображения в vault",
    "command.moveCompressed": "Переместить сжатые файлы",
    "context.compressImage": "Сжать изображение",
    "context.compressImagesInFolder": "Сжать изображения в папке",
    "notice.cacheUpdated": "Кэш обновлен",
    "notice.cacheCleared": "Кэш очищен",
    "section.quality": "Качество сжатия",
    "section.paths": "Настройки путей",
    "section.automation": "Автоматизация",
    "section.stats": "Статистика и кэш",
    "section.move": "Перемещение сжатых файлов",
    "section.cacheBackups": "Бэкапы кеша",
    "section.system": "Система",
    "binaries.available": "Доступно",
    "binaries.notFound": "Не найдено",
    "section.instructions": "Инструкции",
    "quality.png.name": "Качество PNG (мин-макс)",
    "quality.png.desc": "Диапазон качества для сжатия PNG файлов (65-80 по умолчанию)",
    "quality.jpeg.name": "Качество JPEG",
    "quality.jpeg.desc": "Качество сжатия JPEG файлов (1-95)",
    "paths.pngquant.name": "Путь к pngquant",
    "paths.pngquant.desc": "Полный путь к бинарнику pngquant или пусто для автопоиска",
    "paths.mozjpeg.name": "Путь к mozjpeg",
    "paths.mozjpeg.desc": "Полный путь к бинарнику mozjpeg или пусто для автопоиска",
    "paths.allowedRoots.name": "Разрешённые корни",
    "paths.allowedRoots.desc": "Выберите папки, где разрешено сжатие (пусто = все пути)",
    "paths.allowedRoots.empty": "Не выбрано (сжимаем везде)",
    "paths.allowedRoots.pill.remove": "Нажмите, чтобы удалить",
    "paths.allowedRoots.modal.placeholder": "Выберите папку...",
    "paths.allowedRoots.clear": "Очистить список",
    "paths.output.name": "Выходная папка",
    "paths.output.desc": "Имя папки для сохранения сжатых файлов",
    "auto.newFiles.name": "Автосжатие новых файлов",
    "auto.newFiles.desc": "Автоматически сжимать новые изображения при добавлении в vault",
    "auto.bg.name": "Автоматическое фоновое сжатие",
    "auto.bg.desc": "Автоматически сжимать в фоне, когда вы неактивны",
    "auto.bg.threshold.name": "Порог для фонового сжатия",
    "auto.bg.threshold.desc": "Количество несжатых изображений для автозапуска",
    "auto.retention.toggle.name": "Автоудаление бэкапов изображений",
    "auto.retention.toggle.desc": "Удалять бэкапы изображений по сроку хранения",
    "auto.retention.days.name": "Срок хранения бэкапов (дней)",
    "auto.retention.days.desc": "Удалять бэкапы, которым больше указанного количества дней",
    "auto.move.toggle.name": "Автоперемещение сжатых файлов — включить",
    "auto.move.toggle.desc": "Автоматически перемещать сжатые файлы при достижении порога",
    "auto.move.threshold.name": "Порог автоперемещения (шт.)",
    "auto.move.threshold.desc": "Сколько сжатых файлов в 'Compressed' нужно для автоперемещения",
    "auto.cleanupGhosts.name": "Автоочистка призраков при старте",
    "auto.cleanupGhosts.desc": "Автоматически удалять записи кэша, указывающие на удалённые файлы, при запуске Obsidian",
    "stats.uncompressed.name": "Несжатых изображений",
    "stats.uncompressed.ready": "изображений готовы к сжатию",
    "stats.cache.name": "Записей в кэше",
    "stats.cache.entries": "записей",
    "stats.cache.size": "размер",
    "stats.ghosts.name": "Призрачные записи",
    "stats.ghosts.pointToMissing": "записей в кэше ссылаются на удалённые файлы",
    "move.title": "Переместить сжатые файлы",
    "move.ready": "сжатых файлов готовы к перемещению",
    "move.button": "Переместить",
    "move.noCompressedFolder": "Папка Compressed не найдена",
    "move.noneToMove": "Нет сжатых файлов для перемещения",
    "move.noneWithOriginals": "Нет сжатых файлов с оригиналами в разрешённых корнях",
    "backups.imagesFolder.name": "Папка с бэкапами изображений",
    "backups.imagesFolder.desc": "Открыть папку с бэкапами оригинальных/сжатых изображений",
    "backups.imagesFolder.openButton": "Открыть папку бэкапов изображений",
    "backups.imagesFolder.openError": "Не удалось открыть папку бэкапов изображений",
    "backups.cache.title": "Бэкапы кеша",
    "backups.pathLabel": "Путь",
    "backups.foundLabel": "Найдено бэкапов",
    "backups.cache.none": "Нет доступных бэкапов кеша",
    "backups.cache.restore": "Восстановить кеш из бэкапа",
    "backups.cache.available": "Доступно бэкапов:",
    "backups.cache.selectPlaceholder": "-- Выберите бэкап --",
    "common.add": "Добавить",
    "common.refresh": "Обновить",
    "common.clearCache": "Очистить кэш",
    "common.refreshCache": "Обновить кэш",
    "common.clearGhosts": "Очистить призраки",
    "common.clear": "Очистить",
    "units.kb": "КБ",
    "instructions.usageTitle": "Использование:",
    "instructions.notesTitle": "Примечания:",
    "instructions.notes.saved": "Сжатые файлы сохраняются в папку",
    "instructions.notes.originalUnchanged": "Оригинальные файлы не изменяются",
    "instructions.notes.recompressionSkipped": "Повторное сжатие пропускается благодаря кэшу"
    ,"progress.start": "Начинаем обработку..."
    ,"progress.processing": "Обработка"
    ,"progress.skippedAlready": "Пропущен (уже сжат)"
    ,"progress.skipped": "Пропущен"
    ,"progress.compressed": "Сжат"
    ,"progress.error": "Ошибка"
    ,"progress.completed": "Завершено! Сжато"
    ,"folders.noneInVault": "Во vault нет папок"
    ,"folderSelect.title": "Выберите папку для сжатия изображений"
    ,"folderSelect.root": "Корневая папка"
    ,"folderSelect.select": "Выбрать"
    ,"folderSelect.cancel": "Отмена"
    ,"instructions.action.rightClick": "Правый клик по изображению →"
    ,"instructions.action.commandPalette": "Палитра команд →"
    ,"savings.original": "Оригинал"
    ,"savings.current": "Текущий"
    ,"savings.saved": "Сэкономлено"
    ,"tooltip.savings.header": "Детали экономии места"
    ,"tooltip.savings.original": "Исходный размер:"
    ,"tooltip.savings.current": "Текущий размер:"
    ,"tooltip.savings.saved": "Экономия места:"
    ,"tooltip.savings.filesProcessed": "Обработано файлов:"
  },
  uk: {
    "settings.title": "Налаштування",
    "warning.binariesMissing": "Виконувані файли не знайдені: вкажіть шляхи в налаштуваннях або встановіть pngquant/mozjpeg.",
    "command.compressInNote": "Стиснути всі зображення в нотатці",
    "command.compressInFolder": "Стиснути всі зображення в папці",
    "command.compressAll": "Стиснути всі зображення у vault",
    "command.moveCompressed": "Перемістити стиснені файли",
    "context.compressImage": "Стиснути зображення",
    "context.compressImagesInFolder": "Стиснути зображення в папці",
    "notice.cacheUpdated": "Кеш оновлено",
    "notice.cacheCleared": "Кеш очищено",
    "section.quality": "Якість стиснення",
    "section.paths": "Налаштування шляхів",
    "section.automation": "Автоматизація",
    "section.stats": "Статистика та кеш",
    "section.move": "Переміщення стиснених файлів",
    "section.cacheBackups": "Бекапи кешу",
    "section.system": "Система",
    "binaries.available": "Доступно",
    "binaries.notFound": "Не знайдено",
    "section.instructions": "Інструкції",
    "quality.png.name": "Якість PNG (мін-макс)",
    "quality.png.desc": "Діапазон якості для стиснення PNG (65-80 за замовчуванням)",
    "quality.jpeg.name": "Якість JPEG",
    "quality.jpeg.desc": "Якість стиснення JPEG (1-95)",
    "paths.pngquant.name": "Шлях до pngquant",
    "paths.pngquant.desc": "Повний шлях до pngquant або порожньо для автопошуку",
    "paths.mozjpeg.name": "Шлях до mozjpeg",
    "paths.mozjpeg.desc": "Повний шлях до mozjpeg або порожньо для автопошуку",
    "paths.allowedRoots.name": "Дозволені корені",
    "paths.allowedRoots.desc": "Виберіть папки, де дозволено стиснення (порожньо = всі шляхи)",
    "paths.allowedRoots.empty": "Не вибрано (стискаємо всюди)",
    "paths.allowedRoots.pill.remove": "Натисніть, щоб видалити",
    "paths.allowedRoots.modal.placeholder": "Виберіть папку...",
    "paths.allowedRoots.clear": "Очистити список",
    "paths.output.name": "Вихідна папка",
    "paths.output.desc": "Папка для збереження стиснених файлів",
    "auto.newFiles.name": "Автостиснення нових файлів",
    "auto.newFiles.desc": "Автоматично стискати нові зображення при додаванні до vault",
    "auto.bg.name": "Автоматичне фонове стиснення",
    "auto.bg.desc": "Автоматично стискати у фоні, коли ви неактивні",
    "auto.bg.threshold.name": "Поріг для фонового стиснення",
    "auto.bg.threshold.desc": "Кількість нестиснених зображень для автозапуску",
    "auto.retention.toggle.name": "Автоочищення бекапів зображень",
    "auto.retention.toggle.desc": "Видаляти бекапи зображень за строком зберігання",
    "auto.retention.days.name": "Строк зберігання бекапів (днів)",
    "auto.retention.days.desc": "Видаляти бекапи, старші за вказану кількість днів",
    "auto.move.toggle.name": "Увімкнути автопереміщення стиснених файлів",
    "auto.move.toggle.desc": "Автоматично переміщувати стиснені файли при досягненні порогу",
    "auto.move.threshold.name": "Поріг автопереміщення (шт.)",
    "auto.move.threshold.desc": "Скільки файлів у 'Compressed' потрібно для автопереміщення",
    "auto.cleanupGhosts.name": "Автоочищення 'привидів' при старті",
    "auto.cleanupGhosts.desc": "Автоматично видаляти записи кешу, що вказують на видалені файли, при запуску Obsidian",
    "stats.uncompressed.name": "Нестиснених зображень",
    "stats.uncompressed.ready": "зображень готові до стиснення",
    "stats.cache.name": "Записів у кеші",
    "stats.cache.entries": "записів",
    "stats.cache.size": "розмір",
    "stats.ghosts.name": "Привидні записи",
    "stats.ghosts.pointToMissing": "записів у кеші вказують на видалені файли",
    "move.title": "Перемістити стиснені файли",
    "move.ready": "стиснені файли готові до переміщення",
    "move.button": "Перемістити",
    "move.noCompressedFolder": "Папку Compressed не знайдено",
    "move.noneToMove": "Немає стиснених файлів для переміщення",
    "move.noneWithOriginals": "Немає стиснених файлів з оригіналами у дозволених коренях",
    "backups.imagesFolder.name": "Папка з бекапами зображень",
    "backups.imagesFolder.desc": "Відкрити папку з бекапами оригінальних/стиснених зображень",
    "backups.imagesFolder.openButton": "Відкрити папку бекапів зображень",
    "backups.imagesFolder.openError": "Не вдалося відкрити папку бекапів зображень",
    "backups.cache.title": "Бекапи кешу",
    "backups.pathLabel": "Шлях",
    "backups.foundLabel": "Знайдено бекапів",
    "backups.cache.none": "Немає доступних бекапів кешу",
    "backups.cache.restore": "Відновити кеш із бекапу",
    "backups.cache.available": "Доступно бекапів:",
    "backups.cache.selectPlaceholder": "-- Оберіть бекап --",
    "common.add": "Додати",
    "common.refresh": "Оновити",
    "common.clearCache": "Очистити кеш",
    "common.refreshCache": "Оновити кеш",
    "common.clearGhosts": "Очистити привиди",
    "common.clear": "Очистити",
    "units.kb": "КБ",
    "instructions.usageTitle": "Використання:",
    "instructions.notesTitle": "Примітки:",
    "instructions.notes.saved": "Стиснені файли зберігаються в папку",
    "instructions.notes.originalUnchanged": "Оригінальні файли не змінюються",
    "instructions.notes.recompressionSkipped": "Повторне стиснення пропускається завдяки кешу"
    ,"progress.start": "Починаємо обробку..."
    ,"progress.processing": "Обробка"
    ,"progress.skippedAlready": "Пропущено (вже стиснено)"
    ,"progress.skipped": "Пропущено"
    ,"progress.compressed": "Стиснено"
    ,"progress.error": "Помилка"
    ,"progress.completed": "Завершено! Стиснено"
    ,"folders.noneInVault": "У сховищі (vault) немає папок"
    ,"folderSelect.title": "Виберіть папку для стиснення зображень"
    ,"folderSelect.root": "Коренева папка"
    ,"folderSelect.select": "Вибрати"
    ,"folderSelect.cancel": "Скасувати"
    ,"instructions.action.rightClick": "Клацніть правою кнопкою по зображенню →"
    ,"instructions.action.commandPalette": "Палітра команд →"
    ,"savings.original": "Оригінал"
    ,"savings.current": "Поточний"
    ,"savings.saved": "Заощаджено"
    ,"tooltip.savings.header": "Деталі заощадження місця"
    ,"tooltip.savings.original": "Початковий розмір:"
    ,"tooltip.savings.current": "Поточний розмір:"
    ,"tooltip.savings.saved": "Заощаджено місця:"
    ,"tooltip.savings.filesProcessed": "Опрацьовано файлів:"
  }
};
// Optional external translations loader (lang/*.json). Merges over built-ins.
const LOADED_LANGS = {};
function resolvePluginDirFromApp(app) {
  try {
    const configDir = app?.vault?.configDir;
    const adapter = app?.vault?.adapter;
    const basePath = adapter?.path?.absolute || adapter?.basePath || process.cwd();
    return path3.join(basePath, configDir, "plugins", "local-image-compress");
  } catch (_) {
    return process.cwd();
  }
}
function getMergedDict(app, lang) {
  const fullLang = String(lang || "en").toLowerCase();
  if (LOADED_LANGS[fullLang]) return LOADED_LANGS[fullLang];
  const primary = fullLang.split(/[_.-]/)[0] || "en";
  let merged = I18N[primary] || I18N.en || {};
  try {
    const pluginDir = resolvePluginDirFromApp(app);
    const tryFiles = [
      path3.join(pluginDir, "lang", `${fullLang}.json`),
      path3.join(pluginDir, "lang", `${primary}.json`)
    ];
    for (const lf of tryFiles) {
      if (fs3.existsSync(lf)) {
        const raw = fs3.readFileSync(lf, "utf8");
        const ext = JSON.parse(raw);
        merged = Object.assign({}, merged, ext);
      }
    }
  } catch (_) {
    try { console.debug(getLogTag({ manifest: { name: 'Local Image Compress' } }), 'i18n: failed to load external lang file'); } catch {}
  }
  LOADED_LANGS[fullLang] = merged;
  return merged;
}
function getUserLang(app) {
  try {
    // Prefer Obsidian UI language (moment locale), fallback to vault locale
    const uiLocale = import_obsidian2?.moment?.locale?.();
    const fallback = app?.vault?.getConfig?.("locale");
    const detected = uiLocale || fallback || "en";
    const l = String(detected).toLowerCase();
    if (!l) return "en";
    if (l.startsWith("ru")) return "ru";
    if (l.startsWith("uk") || l.startsWith("ua")) return "uk";
    return "en";
  } catch {}
  return "en";
}

function getCurrentLang(app) {
  return getUserLang(app);
}
function t(app, key) {
  const lang = getCurrentLang(app);
  const dict = getMergedDict(app, lang);
  return (dict && dict[key]) || (I18N.en && I18N.en[key]) || key;
}

// path & html helpers
function normalizeVaultPath(p) {
  return String(p || "").replace(/\\/g, "/");
}
function isInsideOutputFolder(targetPath, outputFolderName) {
  const safeOutput = String(outputFolderName || "").trim();
  if (!safeOutput) return false;
  const parts = normalizeVaultPath(targetPath).split("/");
  return parts.includes(safeOutput);
}
function escapeHtml(value) {
  return String(value)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/\"/g, "&quot;")
    .replace(/'/g, "&#039;");
}
function getLogTag(self) {
  try {
    const name = self?.manifest?.name || "Local Image Compress";
    return `[${name}]`;
  } catch (_) {
    return "[Local Image Compress]";
  }
}

function getPluginName(self) {
  try {
    return self?.manifest?.name || "Local Image Compress";
  } catch (_) {
    return "Local Image Compress";
  }
}

function getPluginId(self) {
  try {
    return self?.manifest?.id || 'local-image-compress';
  } catch (_) {
    return 'local-image-compress';
  }
}

// settings.ts
var DEFAULT_SETTINGS = {
  pngQuality: {
    min: 65,
    max: 80
  },
  jpegQuality: 85,
  allowedRoots: [],
  outputFolder: "Compressed",
  autoCompressNewFiles: false,
  autoBackgroundCompression: true,
  autoBackgroundThreshold: 50,
  pngquantPath: "",
  mozjpegPath: "",
  autoCleanupGhostsOnStart: false,
  autoBackupsRetentionEnabled: false,
  autoBackupsRetentionDays: 30,
  autoMoveCompressedEnabled: false,
  autoMoveCompressedThreshold: 50
};

// settings-tab.ts
var import_obsidian = require("obsidian");
var SettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this._isRendering = false;
    this._pendingRerender = false;
    this.rerenderPreservingScroll = () => {
      try {
        const { containerEl } = this;
        const prevScroll = containerEl.scrollTop;
        const active = document.activeElement;
        const restore = () => {
          try {
            containerEl.scrollTop = prevScroll;
            if (active && active.focus) active.focus();
          } catch (_) {}
        };
        // Re-render and restore scroll position
        requestAnimationFrame(async () => {
          await this.display();
          requestAnimationFrame(restore);
        });
      } catch (_) {
        // Fallback
        this.display();
      }
    };
  }
  async display() {
    if (this._isRendering) {
      // If already rendering, mark that a subsequent pass is required
      this._pendingRerender = true;
      return;
    }
    this._isRendering = true;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("tiny-local-settings");
    containerEl.createEl("h2", { text: `${this.plugin.manifest?.name || "Local Image Compress"} — ${t(this.plugin.app, "settings.title")}` });
    
    // Keep references to elements for updates
    this.cacheStatsElement = null;
    this.ghostStatsElement = null;
    this.uncompressedStatsElement = null;
    this.compressedFilesCountElement = null;
    
    // Function to update statistics
    this.updateStats = async () => {
      // Update cache stats
      if (this.cacheStatsElement) {
        const cacheStats = this.plugin.cache.getCacheStats();
        this.cacheStatsElement.setText(`${cacheStats.total} записей, размер: ${Math.round(cacheStats.size / 1024)} КБ`);
      }
      
      // Update ghost entries stats
      if (this.ghostStatsElement) {
        const ghostCount = await this.plugin.getGhostEntriesCount();
        this.ghostStatsElement.setText(`${ghostCount} записей в кэше ссылаются на удаленные файлы`);
      }
      
      // Update uncompressed images stats
      if (this.uncompressedStatsElement) {
        const count = await this.plugin.getUncompressedImagesCount();
        this.uncompressedStatsElement.setText(`${count} изображений готовы к сжатию`);
      }
      
      // Update compressed files count
      if (this.compressedFilesCountElement) {
        const count = await this.plugin.getCompressedFilesCount();
        this.compressedFilesCountElement.setText(`${count} сжатых файлов готовы к перемещению`);
      }
    };
    
    // Global warning if binaries are not found
    const detectedBinariesTop = this.plugin.compressor.checkBinaries();
    if (!detectedBinariesTop.pngquant && !detectedBinariesTop.mozjpeg) {
      const warn = containerEl.createEl("div", { text: t(this.plugin.app, "warning.binariesMissing"), cls: "tiny-local-notice" });
      warn.style.color = "var(--tiny-local-text-error)";
      warn.style.fontWeight = "600";
      warn.style.marginBottom = "8px";
    }

    // Add space savings indicator
    await this.renderSavingsIndicator(containerEl);
    
    // ========================================================================
    // COMPRESSION QUALITY
    // ========================================================================
    containerEl.createEl("h3", { text: t(this.plugin.app, "section.quality") });
    new import_obsidian.Setting(containerEl).setName(t(this.plugin.app, "quality.png.name")).setDesc(t(this.plugin.app, "quality.png.desc")).addText((text) => text.setPlaceholder("65-80").setValue(`${this.plugin.settings.pngQuality.min}-${this.plugin.settings.pngQuality.max}`).onChange(async (value) => {
      const parts = value.split("-");
      if (parts.length === 2) {
        const min = parseInt(parts[0]);
        const max = parseInt(parts[1]);
        if (!isNaN(min) && !isNaN(max) && min >= 0 && max <= 100 && min <= max) {
          this.plugin.settings.pngQuality.min = min;
          this.plugin.settings.pngQuality.max = max;
          await this.plugin.saveSettings();
        }
      }
    }));
    new import_obsidian.Setting(containerEl).setName(t(this.plugin.app, "quality.jpeg.name")).setDesc(t(this.plugin.app, "quality.jpeg.desc")).addSlider((slider) => slider.setLimits(1, 95, 1).setValue(this.plugin.settings.jpegQuality).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.jpegQuality = value;
      await this.plugin.saveSettings();
    }));

    // Button: open image backups folder
    // Removed from "Cache backups" section — moved to "Move compressed files"

    // ========================================================================
    // PATH SETTINGS
    // ========================================================================
    containerEl.createEl("h3", { text: t(this.plugin.app, "section.paths") });
    new import_obsidian.Setting(containerEl)
      .setName(t(this.plugin.app, "paths.pngquant.name"))
      .setDesc(t(this.plugin.app, "paths.pngquant.desc"))
      .addText((text) => text
        .setPlaceholder(process.platform === 'win32' ? "C:\\path\\to\\pngquant.exe" : "/usr/bin/pngquant")
        .setValue(this.plugin.settings.pngquantPath || "")
        .onChange(async (value) => {
          this.plugin.settings.pngquantPath = value.trim();
          await this.plugin.saveSettings();
          // Reinitialize compressor to apply changes
          this.plugin.compressor = new Compressor(this.plugin.getPluginDirectory(), this.plugin.settings);
          await this.updateStats();
        })
      );
    new import_obsidian.Setting(containerEl)
      .setName(t(this.plugin.app, "paths.mozjpeg.name"))
      .setDesc(t(this.plugin.app, "paths.mozjpeg.desc"))
      .addText((text) => text
        .setPlaceholder(process.platform === 'win32' ? "C:\\path\\to\\mozjpeg.exe" : "/usr/bin/mozjpeg")
        .setValue(this.plugin.settings.mozjpegPath || "")
        .onChange(async (value) => {
          this.plugin.settings.mozjpegPath = value.trim();
          await this.plugin.saveSettings();
          this.plugin.compressor = new Compressor(this.plugin.getPluginDirectory(), this.plugin.settings);
          await this.updateStats();
        })
      );
    // Allowed roots: choose from folder list with autocomplete (modal)
    const rootsSetting = new import_obsidian.Setting(containerEl)
      .setName(t(this.plugin.app, "paths.allowedRoots.name"))
      .setDesc(t(this.plugin.app, "paths.allowedRoots.desc"));

    const rootsListEl = rootsSetting.controlEl.createDiv({ cls: "tiny-local-roots-list" });

    const renderRoots = () => {
      rootsListEl.empty();
      if (!Array.isArray(this.plugin.settings.allowedRoots) || this.plugin.settings.allowedRoots.length === 0) {
        rootsListEl.createEl("div", { text: t(this.plugin.app, "paths.allowedRoots.empty"), cls: "setting-item-description" });
        return;
      }
      const list = rootsListEl.createEl("div");
      this.plugin.settings.allowedRoots.forEach((root, idx) => {
        const pill = list.createEl("span", { text: root, cls: "badge" });
        pill.style.marginRight = "6px";
        pill.style.cursor = "pointer";
        pill.title = t(this.plugin.app, "paths.allowedRoots.pill.remove");
        pill.addEventListener("click", async () => {
          this.plugin.settings.allowedRoots.splice(idx, 1);
          await this.plugin.saveSettings();
          renderRoots();
        });
      });
    };

    rootsSetting.addButton((btn) =>
      btn.setButtonText(t(this.plugin.app, "common.add")).onClick(async () => {
        const folders = this.app.vault.getAllLoadedFiles()
          .filter((f) => f instanceof import_obsidian.TFolder)
          .map((f) => f.path);
        // Simple selection modal with filter
        const modal = new (class extends import_obsidian.FuzzySuggestModal {
          constructor(app, items, onChoose) {
            super(app);
            this.items = items;
            this.onChooseCb = onChoose;
            this.setPlaceholder(t(app, "paths.allowedRoots.modal.placeholder"));
          }
          getItems() { return this.items; }
          getItemText(item) { return item; }
          onChooseItem(item) { this.onChooseCb(item); }
        })(this.app, folders, async (chosen) => {
          const normalized = (chosen.endsWith("/")) ? chosen : `${chosen}/`;
          if (!this.plugin.settings.allowedRoots.includes(normalized)) {
            this.plugin.settings.allowedRoots.push(normalized);
            await this.plugin.saveSettings();
            renderRoots();
          }
        });
        modal.open();
      })
    ).addExtraButton((btn) =>
      btn.setIcon("trash").setTooltip(t(this.plugin.app, "paths.allowedRoots.clear")).onClick(async () => {
        this.plugin.settings.allowedRoots = [];
        await this.plugin.saveSettings();
        renderRoots();
      })
    );

    // Mark the trash icon with a class for styling (red hover)
    try {
      const icons = rootsSetting.controlEl.querySelectorAll('.clickable-icon');
      const lastIcon = icons[icons.length - 1];
      if (lastIcon) lastIcon.classList.add('tiny-local-roots-clear');
    } catch (_) {}

    renderRoots();
    new import_obsidian.Setting(containerEl).setName(t(this.plugin.app, "paths.output.name")).setDesc(t(this.plugin.app, "paths.output.desc")).addText((text) => text.setPlaceholder("Compressed").setValue(this.plugin.settings.outputFolder).onChange(async (value) => {
      this.plugin.settings.outputFolder = value.trim() || "Compressed";
      await this.plugin.saveSettings();
    }));
    
    // ========================================================================
    // AUTOMATION
    // ========================================================================
    containerEl.createEl("h3", { text: t(this.plugin.app, "section.automation") });
    new import_obsidian.Setting(containerEl).setName(t(this.plugin.app, "auto.newFiles.name")).setDesc(t(this.plugin.app, "auto.newFiles.desc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.autoCompressNewFiles).onChange(async (value) => {
      this.plugin.settings.autoCompressNewFiles = value;
      await this.plugin.saveSettings();
    }));
    // Background compression + conditional threshold slider (without full re-render)
    const bgSetting = new import_obsidian.Setting(containerEl).setName(t(this.plugin.app, "auto.bg.name")).setDesc(t(this.plugin.app, "auto.bg.desc"));
    bgSetting.addToggle((toggle) => toggle.setValue(this.plugin.settings.autoBackgroundCompression).onChange(async (value) => {
      this.plugin.settings.autoBackgroundCompression = value;
      await this.plugin.saveSettings();
      thresholdRow.settingEl.toggle(value);
    }));
    const thresholdRow = new import_obsidian.Setting(containerEl).setName(t(this.plugin.app, "auto.bg.threshold.name")).setDesc(t(this.plugin.app, "auto.bg.threshold.desc"));
    thresholdRow.addSlider((slider) => slider
      .setLimits(10, 1000, 5)
      .setValue(this.plugin.settings.autoBackgroundThreshold)
      .setDynamicTooltip()
      .onChange(async (value) => {
        this.plugin.settings.autoBackgroundThreshold = value;
        this.plugin.AUTO_BACKGROUND_THRESHOLD = value;
        await this.plugin.saveSettings();
      })
    );
    thresholdRow.settingEl.toggle(this.plugin.settings.autoBackgroundCompression);
    thresholdRow.settingEl.addClass('tiny-local-subsetting');

    // Backups retention: toggle + slider
    const retentionToggle = new import_obsidian.Setting(containerEl).setName(t(this.plugin.app, "auto.retention.toggle.name")).setDesc(t(this.plugin.app, "auto.retention.toggle.desc"));
    retentionToggle.addToggle((toggle) => toggle.setValue(this.plugin.settings.autoBackupsRetentionEnabled).onChange(async (value) => {
      this.plugin.settings.autoBackupsRetentionEnabled = value;
      await this.plugin.saveSettings();
      retentionRow.settingEl.toggle(value);
    }));
    const retentionRow = new import_obsidian.Setting(containerEl).setName(t(this.plugin.app, "auto.retention.days.name")).setDesc(t(this.plugin.app, "auto.retention.days.desc"));
    retentionRow.addSlider((slider) => slider
      .setLimits(1, 365, 1)
      .setValue(this.plugin.settings.autoBackupsRetentionDays)
      .setDynamicTooltip()
      .onChange(async (value) => {
        this.plugin.settings.autoBackupsRetentionDays = value;
        await this.plugin.saveSettings();
      })
    );
    retentionRow.settingEl.toggle(this.plugin.settings.autoBackupsRetentionEnabled);
    retentionRow.settingEl.addClass('tiny-local-subsetting');

    // Auto-move compressed files: toggle + count slider
    const autoMoveToggle = new import_obsidian.Setting(containerEl).setName(t(this.plugin.app, "auto.move.toggle.name")).setDesc(t(this.plugin.app, "auto.move.toggle.desc"));
    autoMoveToggle.addToggle((toggle) => toggle.setValue(this.plugin.settings.autoMoveCompressedEnabled).onChange(async (value) => {
      this.plugin.settings.autoMoveCompressedEnabled = value;
      await this.plugin.saveSettings();
      autoMoveRow.settingEl.toggle(value);
    }));
    const autoMoveRow = new import_obsidian.Setting(containerEl).setName(t(this.plugin.app, "auto.move.threshold.name")).setDesc(t(this.plugin.app, "auto.move.threshold.desc"));
    autoMoveRow.addSlider((slider) => slider
      .setLimits(1, 1000, 1)
      .setValue(this.plugin.settings.autoMoveCompressedThreshold)
      .setDynamicTooltip()
      .onChange(async (value) => {
        this.plugin.settings.autoMoveCompressedThreshold = value;
        await this.plugin.saveSettings();
      })
    );
    autoMoveRow.settingEl.toggle(this.plugin.settings.autoMoveCompressedEnabled);
    autoMoveRow.settingEl.addClass('tiny-local-subsetting');
    // Add at the end of Automation section
    new import_obsidian.Setting(containerEl).setName(t(this.plugin.app, "auto.cleanupGhosts.name")).setDesc(t(this.plugin.app, "auto.cleanupGhosts.desc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.autoCleanupGhostsOnStart).onChange(async (value) => {
      this.plugin.settings.autoCleanupGhostsOnStart = value;
      await this.plugin.saveSettings();
    }));
    // ========================================================================
    // STATISTICS & CACHE
    // ========================================================================
    containerEl.createEl("h3", { text: t(this.plugin.app, "section.stats") });
    const uncompressedCount = await this.plugin.getUncompressedImagesCount();
    const uncompressedSetting = new import_obsidian.Setting(containerEl).setName(t(this.plugin.app, "stats.uncompressed.name")).setDesc(`${uncompressedCount} ${t(this.plugin.app, "stats.uncompressed.ready")}`);
    this.uncompressedStatsElement = uncompressedSetting.descEl;
    uncompressedSetting.addButton((button) => button.setButtonText(t(this.plugin.app, "common.refresh")).onClick(async () => {
      await this.plugin.forceRefreshCache();
      await this.updateStats();
      new import_obsidian.Notice(`${getPluginName(this)}: ${t(this.plugin.app, "notice.cacheUpdated")}`);
    }));
    const cacheStats = this.plugin.cache.getCacheStats();
    const cacheSetting = new import_obsidian.Setting(containerEl).setName(t(this.plugin.app, "stats.cache.name")).setDesc(`${cacheStats.total} ${t(this.plugin.app, "stats.cache.entries")}, ${t(this.plugin.app, "stats.cache.size")}: ${Math.round(cacheStats.size / 1024)} ${t(this.plugin.app, "units.kb")}`);
    this.cacheStatsElement = cacheSetting.descEl;
    cacheSetting.addButton((button) => button.setButtonText(t(this.plugin.app, "common.clearCache")).setWarning().onClick(async () => {
      await this.plugin.cache.clearCache();
      await this.plugin.updateStatusBar();
      await this.updateStats();
      new import_obsidian.Notice(`${getPluginName(this)}: ${t(this.plugin.app, "notice.cacheCleared")}`);
    })).addButton((button) => button.setButtonText(t(this.plugin.app, "common.refreshCache")).onClick(async () => {
      await this.plugin.forceRefreshCache();
      await this.updateStats();
      new import_obsidian.Notice(`${getPluginName(this)}: ${t(this.plugin.app, "notice.cacheUpdated")}`);
    }));
    const ghostCount = await this.plugin.getGhostEntriesCount();
    const ghostSetting = new import_obsidian.Setting(containerEl).setName(t(this.plugin.app, "stats.ghosts.name")).setDesc(`${ghostCount} ${t(this.plugin.app, "stats.ghosts.pointToMissing")}`);
    this.ghostStatsElement = ghostSetting.descEl;
    ghostSetting.addButton((button) => button.setButtonText(t(this.plugin.app, "common.clearGhosts")).setWarning().onClick(async () => {
      const removedCount = await this.plugin.cleanupGhostEntries();
      await this.updateStats();
      new import_obsidian.Notice(`${getPluginName(this)}: ${removedCount} ${t(this.plugin.app, "stats.ghosts.name").toLowerCase()} ${t(this.plugin.app, "common.clear")}`);
    }));
    
    // ========================================================================
    // AUTO MOVE
    // ========================================================================
    containerEl.createEl("h3", { text: t(this.plugin.app, "section.move") });
    
    // Button: move compressed files
    const compressedCount = await this.plugin.getCompressedFilesCount();
    const moveSetting = new import_obsidian.Setting(containerEl).setName(t(this.plugin.app, "move.title")).setDesc(`${compressedCount} ${t(this.plugin.app, "move.ready")}`);
    this.compressedFilesCountElement = moveSetting.descEl;
    moveSetting.addButton((button) => button.setButtonText(t(this.plugin.app, "move.button")).setWarning().onClick(async () => {
      await this.plugin.moveCompressedToFiles();
      // Update all stats after operation
      await this.updateStats();
    }));
    
    // Button: clear backups of moved files
    new import_obsidian.Setting(containerEl).setName(t(this.plugin.app, "common.clear")).setDesc(" ").addButton((button) => button.setButtonText(t(this.plugin.app, "common.clear")).setWarning().onClick(async () => {
      await this.plugin.clearOriginalFilesBackups();
    }));

    // Button: open image backups folder
    new import_obsidian.Setting(containerEl)
      .setName(t(this.plugin.app, "backups.imagesFolder.name"))
      .setDesc(t(this.plugin.app, "backups.imagesFolder.desc"))
      .addButton((button) => button
        .setButtonText(t(this.plugin.app, "backups.imagesFolder.openButton"))
        .onClick(async () => {
          try {
            const pluginDir = this.plugin.getPluginDirectory();
            const dir = path3.join(pluginDir, "original-files-backups");
            if (!fs3.existsSync(dir)) {
              fs3.mkdirSync(dir, { recursive: true });
            }
            const { shell } = require('electron');
            const err = await shell.openPath(dir);
            if (err) {
              console.error(getLogTag(this), 'Error opening image backups folder:', err);
              new import_obsidian.Notice(`${getPluginName(this)}: ${t(this.plugin.app, "backups.imagesFolder.openError")}`);
            }
          } catch (e) {
            console.error(getLogTag(this), 'Error opening image backups folder:', e);
            new import_obsidian.Notice(`${getPluginName(this)}: ${t(this.plugin.app, "backups.imagesFolder.openError")}`);
            new import_obsidian.Notice(`${getPluginName(this)}: ${t(this.plugin.app, "backups.imagesFolder.openError")}`);
          }
        })
      );
    
    // ========================================================================
    // BACKUPS
    // ========================================================================
    containerEl.createEl("h3", { text: t(this.plugin.app, "backups.cache.title") });
    const backups = this.plugin.cache.getAvailableBackups();
    if (backups.length === 0) {
      new import_obsidian.Setting(containerEl).setName(t(this.plugin.app, "backups.cache.title")).setDesc(t(this.plugin.app, "backups.cache.none")).setDisabled(true);
    } else {
      new import_obsidian.Setting(containerEl).setName(t(this.plugin.app, "backups.cache.restore")).setDesc(`${t(this.plugin.app, "backups.cache.available")} ${backups.length}`).addDropdown((dropdown) => {
        dropdown.addOption("", t(this.plugin.app, "backups.cache.selectPlaceholder"));
        backups.forEach((backup) => {
          const date = backup.replace("tinyLocal-cache-backup-", "").replace(".json", "").replace(/-/g, ":").replace(/T/, " ");
          dropdown.addOption(backup, date);
        });
        dropdown.onChange(async (value) => {
          if (value) {
            const success = await this.plugin.cache.restoreFromBackup(value);
            if (success) {
              await this.plugin.updateStatusBar();
              await this.updateStats();
              // Immediately update savings indicator in settings
              this.plugin.updateSavingsIndicatorInSettings();
              new import_obsidian.Notice(`${getPluginName(this)}: ${t(this.plugin.app, "notice.cacheUpdated")}`);
            } else {
              new import_obsidian.Notice(`${getPluginName(this)}: ${t(this.plugin.app, "notice.cacheCleared")}`);
            }
          }
        });
      });
    }
    new import_obsidian.Setting(containerEl).setName(t(this.plugin.app, "backups.cache.title")).setDesc(t(this.plugin.app, "backups.imagesFolder.desc")).addButton((button) => button.setButtonText(t(this.plugin.app, "backups.imagesFolder.openButton")).onClick(async () => {
      await this.plugin.openBackupsFolder();
    }));

    // (Moved to "Move compressed files" section)
    
    // ========================================================================
    // SYSTEM
    // ========================================================================
    containerEl.createEl("h3", { text: t(this.plugin.app, "section.system") });
    const compressor = this.plugin.compressor;
    const binaries = compressor.checkBinaries();
    
    // Current versions (no latest checks)
    const versions = {
      pngquant: { current: await this.plugin.getCurrentPngquantVersion() },
      mozjpeg: { current: await this.plugin.getCurrentMozjpegVersion() }
    };
    
    // pngquant: localized availability
    let pngquantDesc = binaries.pngquant ? `\u2713 ${t(this.plugin.app, "binaries.available")}` : `\u2717 ${t(this.plugin.app, "binaries.notFound")}`;
    if (binaries.pngquant && versions.pngquant.current) {
      pngquantDesc += ` (v${versions.pngquant.current})`;
    }
    
    // mozjpeg: localized availability
    let mozjpegDesc = binaries.mozjpeg ? `\u2713 ${t(this.plugin.app, "binaries.available")}` : `\u2717 ${t(this.plugin.app, "binaries.notFound")}`;
    if (binaries.mozjpeg && versions.mozjpeg.current) {
      mozjpegDesc += ` (v${versions.mozjpeg.current})`;
    }
    
    new import_obsidian.Setting(containerEl).setName("pngquant").setDesc(pngquantDesc).setDisabled(true);
    new import_obsidian.Setting(containerEl).setName("mozjpeg").setDesc(mozjpegDesc).setDisabled(true);
    
    // ========================================================================
    // INSTRUCTIONS
    // ========================================================================
    containerEl.createEl("h3", { text: t(this.plugin.app, "section.instructions") });
    const instructions = containerEl.createEl("div", { cls: "setting-item-description" });
    instructions.innerHTML = `
			<p><strong>${t(this.plugin.app, 'instructions.usageTitle')}</strong></p>
			<ul>
				<li>${t(this.plugin.app, 'instructions.action.rightClick')} "${t(this.plugin.app, 'context.compressImage')}"</li>
				<li>${t(this.plugin.app, 'instructions.action.commandPalette')} "${t(this.plugin.app, 'command.compressInNote')}"</li>
				<li>${t(this.plugin.app, 'instructions.action.commandPalette')} "${t(this.plugin.app, 'command.compressInFolder')}"</li>
				<li>${t(this.plugin.app, 'instructions.action.commandPalette')} "${t(this.plugin.app, 'command.compressAll')}"</li>
				<li>${t(this.plugin.app, 'instructions.action.commandPalette')} "${t(this.plugin.app, 'command.moveCompressed')}"</li>
			</ul>
			<p><strong>${t(this.plugin.app, 'instructions.notesTitle')}</strong></p>
			<ul>
				<li>${t(this.plugin.app, 'instructions.notes.saved')} "${escapeHtml(this.plugin.settings.outputFolder)}"</li>
				<li>${t(this.plugin.app, 'instructions.notes.originalUnchanged')}</li>
				<li>${t(this.plugin.app, 'instructions.notes.recompressionSkipped')}</li>
			</ul>
		`;
  }
  
  async renderSavingsIndicator(containerEl) {
    try {
      // Check whether we should show the savings indicator
      if (!this.plugin.shouldShowSavingsIndicator()) {
        return;
      }
      
      // Additional check for valid data presence
      if (!(await this.plugin.hasValidSavingsData())) {
        return;
      }
      
      const savings = await this.plugin.calculateSpaceSavings();
      
      if (!this.plugin.validateSavingsData(savings)) {
        return; // Do not render if data is not valid
      }
      
      // Create container for indicator
      const indicatorContainer = containerEl.createEl("div", {
        cls: "tiny-local-savings-indicator"
      });
      
      // Create textual summary
      const textInfo = indicatorContainer.createEl("div", {
        cls: "tiny-local-savings-text"
      });
      
      const { originalFormatted, currentFormatted, savedFormatted, estimatedIndicator } = this.plugin.formatTooltipData(savings);
      
      textInfo.innerHTML = `
        <strong>${t(this.plugin.app, 'savings.original')}:</strong> ${originalFormatted}${estimatedIndicator} → 
        <strong>${t(this.plugin.app, 'savings.current')}:</strong> ${currentFormatted} → 
        <strong>${t(this.plugin.app, 'savings.saved')}:</strong> ${savedFormatted} (${savings.savedPercentage}%)${estimatedIndicator}
      `;
      
      // Create progress bar
      const barContainer = indicatorContainer.createEl("div", {
        cls: "tiny-local-savings-bar"
      });
      
      // Compute bar proportions with divide-by-zero protection
      const totalWidth = 100;
      const savedWidth = savings.originalSize > 0 ? Math.min(100, Math.max(0, (savings.savedSize / savings.originalSize) * totalWidth)) : 0;
      const currentWidth = Math.max(0, totalWidth - savedWidth);
      

      
      // Create saved space segment
      if (savedWidth > 0) {
        const savedBlock = barContainer.createEl("div", {
          cls: "tiny-local-savings-saved"
        });
        savedBlock.style.width = `${savedWidth}%`;
      }
      
      // Create current size segment (always create, even if 0%)
      const currentBlock = barContainer.createEl("div", {
        cls: "tiny-local-savings-current"
      });
      currentBlock.style.width = `${currentWidth}%`;
      
      // Fallback: if both are 0, render empty block for visibility
      if (savedWidth === 0 && currentWidth === 0) {
        const fallbackBlock = barContainer.createEl("div", {
          cls: "tiny-local-savings-current"
        });
        fallbackBlock.style.width = "100%";
      }
      
      // Attach tooltip
      this.createSavingsTooltip(indicatorContainer, savings);
      
    } catch (error) {
      console.error(getLogTag(this), "Savings indicator render error:", error);
    }
  }
  
  createSavingsTooltip(container, savings) {
    try {
      const { originalFormatted, currentFormatted, savedFormatted, estimatedIndicator, estimatedText } = this.plugin.formatTooltipData(savings);
      
      const tooltipContent = `
        <div class="tiny-local-savings-tooltip">
          <div class="tooltip-header">${t(this.plugin.app, 'tooltip.savings.header')}</div>
          <div class="tooltip-item">
            <span class="tooltip-label">${t(this.plugin.app, 'tooltip.savings.original')}</span>
            <span class="tooltip-value">${originalFormatted}${estimatedIndicator}</span>
          </div>
          <div class="tooltip-item">
            <span class="tooltip-label">${t(this.plugin.app, 'tooltip.savings.current')}</span>
            <span class="tooltip-value">${currentFormatted}</span>
          </div>
          <div class="tooltip-item">
            <span class="tooltip-label">${t(this.plugin.app, 'tooltip.savings.saved')}</span>
            <span class="tooltip-value">${savedFormatted} (${savings.savedPercentage}%)${estimatedIndicator}</span>
          </div>
          <div class="tooltip-item">
            <span class="tooltip-label">${t(this.plugin.app, 'tooltip.savings.filesProcessed')}</span>
            <span class="tooltip-value">${savings.processedFiles} / ${savings.totalFiles}${estimatedText}</span>
          </div>
        </div>
      `;
      
      // Create custom tooltip
      let tooltip = null;
      let isMouseOver = false;
      
      const showTooltip = (e) => {
        if (tooltip || !isMouseOver) return;
        
        tooltip = document.createElement('div');
        tooltip.innerHTML = tooltipContent;
        tooltip.style.position = 'absolute';
        tooltip.style.zIndex = '1000';
        tooltip.style.pointerEvents = 'none';
        
        document.body.appendChild(tooltip);
        
        // Position tooltip after a frame to ensure proper sizes
        requestAnimationFrame(() => {
          if (!tooltip || !document.body.contains(tooltip)) return;
          
          const rect = container.getBoundingClientRect();
          const tooltipRect = tooltip.getBoundingClientRect();
          
          let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
          let top = rect.top - tooltipRect.height - 10;
          
          // Ensure on-screen positioning
          const margin = 10;
          const maxLeft = window.innerWidth - tooltipRect.width - margin;
          const maxTop = window.innerHeight - tooltipRect.height - margin;
          
          left = Math.max(margin, Math.min(left, maxLeft));
          
          if (top < margin) {
            top = rect.bottom + margin;
          }
          top = Math.max(margin, Math.min(top, maxTop));
          
          tooltip.style.left = left + 'px';
          tooltip.style.top = top + 'px';
        });
      };
      
      const hideTooltip = () => {
        if (tooltip && document.body.contains(tooltip)) {
          document.body.removeChild(tooltip);
        }
        tooltip = null;
        isMouseOver = false;
      };
      
      container.addEventListener('mouseenter', (e) => {
        isMouseOver = true;
        setTimeout(() => showTooltip(e), 200); // Small delay to prevent flicker
      });
      
      container.addEventListener('mouseleave', () => {
        isMouseOver = false;
        setTimeout(hideTooltip, 100);
      });
      
      container.style.cursor = "help";
    } catch (error) {
      console.error(getLogTag(this), "Tooltip creation error:", error);
    }
    // Finish render and optionally schedule rerender if pending
    this._isRendering = false;
    if (this._pendingRerender) {
      this._pendingRerender = false;
      // Schedule rerender in next frame
      requestAnimationFrame(() => this.display());
    }
  }
};

// compressor.ts
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));
var os = __toESM(require("os"));
var import_child_process = require("child_process");
var Compressor = class {
  constructor(pluginDir, settings) {
    this.pngquantPath = null;
    this.mozjpegPath = null;
    this.initializeBinaries(pluginDir, settings);
  }
  initializeBinaries(pluginDir, settings) {
    try {
      const baseDir = pluginDir || process.cwd();
      const platform = process.platform;
      const arch = process.arch;
      const normalizedDir = path.resolve(baseDir).replace(/\//g, "\\");
      // 1) User-provided paths from settings (priority)
      const userPngquant = settings?.pngquantPath?.trim();
      const userMozjpeg = settings?.mozjpegPath?.trim();
      if (userPngquant) this.pngquantPath = userPngquant;
      if (userMozjpeg) this.mozjpegPath = userMozjpeg;

      // 2) Resolve from PATH if still not found
      const which = (cmd) => {
        try {
          const result = (0, import_child_process.execSync)(process.platform === 'win32' ? `where ${cmd}` : `which ${cmd}`, { stdio: ['ignore', 'pipe', 'ignore'] }).toString().split(/\r?\n/)[0].trim();
          return result || null;
        } catch {
          return null;
        }
      };
      if (!this.pngquantPath) this.pngquantPath = which('pngquant');
      if (!this.mozjpegPath) this.mozjpegPath = which('cjpeg');

      // 3) Bundled binaries inside plugin folder (fallback)
      if (!this.pngquantPath) {
        this.pngquantPath = path.join(normalizedDir, "node_modules", "pngquant-bin", "vendor", process.platform === 'win32' ? "pngquant.exe" : "pngquant");
      }
      if (!this.mozjpegPath) {
        this.mozjpegPath = path.join(normalizedDir, "node_modules", "mozjpeg", "vendor", process.platform === 'win32' ? "cjpeg.exe" : "cjpeg");
      }
    } catch (error) {
    }
  }
  checkBinaries() {
    const hasPngquant = Boolean(this.pngquantPath && fs.existsSync(this.pngquantPath));
    const hasMozjpeg = Boolean(this.mozjpegPath && fs.existsSync(this.mozjpegPath));
    return { pngquant: hasPngquant, mozjpeg: hasMozjpeg };
  }
  async compress(file, settings) {
    try {
      const adapter = file.vault.adapter;
      const basePath = adapter.path?.absolute || adapter.basePath || process.cwd();
      const filePath = path.join(basePath, file.path);
      const fileExtension = path.extname(file.path).toLowerCase();
      try {
        const stats = fs.statSync(filePath);
        const fd = fs.openSync(filePath, "r");
        const buffer = Buffer.alloc(10);
        fs.readSync(fd, buffer, 0, 10, 0);
        fs.closeSync(fd);
        var originalSize = stats.size;
      } catch (error) {
        return {
          success: false,
          error: `\u041D\u0435\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C \u0434\u043E\u0441\u0442\u0443\u043F \u043A \u0444\u0430\u0439\u043B\u0443: ${error instanceof Error ? error.message : "\u043D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430"}`
        };
      }
      const tempDir = os.tmpdir();
      const tempFileName = `tinylocal_${Date.now()}${fileExtension}`;
      const tempFilePath = path.join(tempDir, tempFileName);
      try {
        fs.copyFileSync(filePath, tempFilePath);
        let result;
        if (fileExtension === ".png") {
          result = await this.compressPNG(tempFilePath, basePath, file.path, settings, originalSize);
        } else if ([".jpg", ".jpeg"].includes(fileExtension)) {
          result = await this.compressJPEG(tempFilePath, basePath, file.path, settings, originalSize);
        } else {
          result = {
            success: false,
            error: "\u041D\u0435\u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u043C\u044B\u0439 \u0444\u043E\u0440\u043C\u0430\u0442 \u0444\u0430\u0439\u043B\u0430"
          };
        }
        try {
          fs.unlinkSync(tempFilePath);
        } catch (cleanupError) {
        }
        return result;
      } catch (copyError) {
        if (fileExtension === ".png") {
          return await this.compressPNG(filePath, basePath, file.path, settings, originalSize);
        } else if ([".jpg", ".jpeg"].includes(fileExtension)) {
          return await this.compressJPEG(filePath, basePath, file.path, settings, originalSize);
        } else {
          return {
            success: false,
            error: "\u041D\u0435\u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u043C\u044B\u0439 \u0444\u043E\u0440\u043C\u0430\u0442 \u0444\u0430\u0439\u043B\u0430"
          };
        }
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430"
      };
    }
  }
  async compressPNG(filePath, basePath, relativePath, settings, originalSize) {
    if (!this.pngquantPath) {
      return {
        success: false,
        error: "pngquant \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D"
      };
    }
    const tempOutputPath = path.join(os.tmpdir(), `tinylocal_out_${Date.now()}.png`);
    const finalOutputPath = this.getOutputPath(basePath, relativePath, settings.outputFolder);
    await this.ensureOutputDirectory(finalOutputPath);
    const args = [
      "--quality",
      `${settings.pngQuality.min}-${settings.pngQuality.max}`,
      "--force",
      "--output",
      tempOutputPath,
      filePath
    ];
    return new Promise((resolve2) => {
      const process2 = (0, import_child_process.spawn)(this.pngquantPath, args);
      let stderr = "";
      process2.stderr?.on("data", (data) => {
        stderr += data.toString();
      });
      process2.on("close", (code) => {
        if (code === 0) {
          try {
            const compressedSize = fs.statSync(tempOutputPath).size;
            const savings = Math.round((originalSize - compressedSize) / originalSize * 100);
            fs.copyFileSync(tempOutputPath, finalOutputPath);
            try {
              fs.unlinkSync(tempOutputPath);
            } catch (cleanupError) {
            }
            resolve2({
              success: true,
              savings
            });
          } catch (error) {
            resolve2({
              success: false,
              error: `\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0441\u0436\u0430\u0442\u044B\u0439 \u0444\u0430\u0439\u043B: ${error instanceof Error ? error.message : "\u043D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430"}`
            });
          }
        } else {
          try {
            fs.unlinkSync(tempOutputPath);
          } catch (cleanupError) {
          }
          resolve2({
            success: false,
            error: `pngquant \u0437\u0430\u0432\u0435\u0440\u0448\u0438\u043B\u0441\u044F \u0441 \u043A\u043E\u0434\u043E\u043C ${code}: ${stderr}`
          });
        }
      });
      process2.on("error", (error) => {
        resolve2({
          success: false,
          error: `\u041E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u043F\u0443\u0441\u043A\u0430 pngquant: ${error.message}`
        });
      });
    });
  }
  async compressJPEG(filePath, basePath, relativePath, settings, originalSize) {
    if (!this.mozjpegPath) {
      return {
        success: false,
        error: "mozjpeg \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D"
      };
    }
    const tempOutputPath = path.join(os.tmpdir(), `tinylocal_out_${Date.now()}.jpg`);
    const finalOutputPath = this.getOutputPath(basePath, relativePath, settings.outputFolder);
    await this.ensureOutputDirectory(finalOutputPath);
    const args = [
      "-quality",
      settings.jpegQuality.toString(),
      "-optimize",
      "-outfile",
      tempOutputPath,
      filePath
    ];
    return new Promise((resolve2) => {
      const process2 = (0, import_child_process.spawn)(this.mozjpegPath, args);
      let stderr = "";
      process2.stderr?.on("data", (data) => {
        stderr += data.toString();
      });
      process2.on("close", (code) => {
        if (code === 0) {
          try {
            const compressedSize = fs.statSync(tempOutputPath).size;
            const savings = Math.round((originalSize - compressedSize) / originalSize * 100);
            fs.copyFileSync(tempOutputPath, finalOutputPath);
            try {
              fs.unlinkSync(tempOutputPath);
            } catch (cleanupError) {
            }
            resolve2({
              success: true,
              savings
            });
          } catch (error) {
            resolve2({
              success: false,
              error: `\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0441\u0436\u0430\u0442\u044B\u0439 JPEG \u0444\u0430\u0439\u043B: ${error instanceof Error ? error.message : "\u043D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430"}`
            });
          }
        } else {
          try {
            fs.unlinkSync(tempOutputPath);
          } catch (cleanupError) {
          }
          resolve2({
            success: false,
            error: `mozjpeg \u0437\u0430\u0432\u0435\u0440\u0448\u0438\u043B\u0441\u044F \u0441 \u043A\u043E\u0434\u043E\u043C ${code}: ${stderr}`
          });
        }
      });
      process2.on("error", (error) => {
        resolve2({
          success: false,
          error: `\u041E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u043F\u0443\u0441\u043A\u0430 mozjpeg: ${error.message}`
        });
      });
    });
  }
  getOutputPath(basePath, relativePath, outputFolder) {
    const outputPath = path.join(basePath, outputFolder, relativePath);
    return outputPath;
  }
  async ensureOutputDirectory(outputPath) {
    const outputDir = path.dirname(outputPath);
    if (!fs.existsSync(outputDir)) {
      await fs.promises.mkdir(outputDir, { recursive: true });
    }
  }
};

// cache.ts
var fs2 = __toESM(require("fs"));
var path2 = __toESM(require("path"));
var crypto = __toESM(require("crypto"));
var Cache = class {
  constructor(app) {
    this.CACHE_VERSION = "1.0.0";
    this.app = app;
    const manifestDir = app.manifest?.dir;
    const configDir = app.vault.configDir;
    const adapter = app.vault.adapter;
    const basePath = adapter.path?.absolute || adapter.basePath || process.cwd();
    let cacheDir;
    if (manifestDir) {
      cacheDir = manifestDir.startsWith("/") || manifestDir.includes(":") ? manifestDir : `${basePath}/${manifestDir}`.replace(/\\/g, "/");
    } else {
      cacheDir = `${basePath}/${configDir}/plugins/local-image-compress`.replace(/\\/g, "/");
    }
    this.cacheFile = path2.join(cacheDir, "tinyLocal-cache.json");
    this.cacheData = {
      entries: {},
      version: this.CACHE_VERSION
    };
    this.loadCacheSync();
  }
  loadCacheSync() {
    try {
      const cacheDir = path2.dirname(this.cacheFile);
      if (!fs2.existsSync(cacheDir)) {
        fs2.mkdirSync(cacheDir, { recursive: true });
      }
      if (!fs2.existsSync(this.cacheFile)) {
        const initialCache = {
          entries: {},
          version: this.CACHE_VERSION
        };
        fs2.writeFileSync(this.cacheFile, JSON.stringify(initialCache, null, 2));
      }
      if (fs2.existsSync(this.cacheFile)) {
        const data = fs2.readFileSync(this.cacheFile, "utf8");
        const parsed = JSON.parse(data);
        if (parsed.version === this.CACHE_VERSION) {
          this.cacheData = parsed;
        } else {
          this.cacheData = {
            entries: {},
            version: this.CACHE_VERSION
          };
        }
      }
    } catch (error) {
      this.cacheData = {
        entries: {},
        version: this.CACHE_VERSION
      };
    }
  }
  async saveCache() {
    try {
      const cacheDir = path2.dirname(this.cacheFile);
      if (!fs2.existsSync(cacheDir)) {
        fs2.mkdirSync(cacheDir, { recursive: true });
      }
      await fs2.promises.writeFile(this.cacheFile, JSON.stringify(this.cacheData, null, 2));
    } catch (error) {
    }
  }
  async getCacheKey(file) {
    try {
      const buffer = await this.app.vault.readBinary(file);
      const uint8Buffer = new Uint8Array(buffer);
      const md5 = crypto.createHash("md5").update(uint8Buffer).digest("hex");
      const mtime = file.stat.mtime;
      return `${file.path}:${md5}:${mtime}`;
    } catch (error) {
      return `${file.path}:${Date.now()}`;
    }
  }
  async isCached(cacheKey) {
    const entry = this.cacheData.entries[cacheKey];
    if (!entry) {
      return false;
    }
    return true;
  }
  // Enhanced method: check cache only by file path
  async isFileAlreadyCompressed(filePath) {
    for (const [cacheKey, entry] of Object.entries(this.cacheData.entries)) {
      const keyPath = cacheKey.split(":")[0];
      if (keyPath === filePath) {
        return true;
      }
    }
    return false;
  }
  // New method: force cache refresh (skip timestamp validation)
  async forceRefreshCache() {
    this.loadCacheSync();
  }
  async addToCache(cacheKey, originalSize = null) {
    try {
      this.cacheData.entries[cacheKey] = {
        md5: cacheKey.split(":")[1] || "",
        mtime: parseInt(cacheKey.split(":")[2]) || Date.now(),
        timestamp: Date.now(),
        originalSize: originalSize // Preserve original size
      };
      await this.saveCache();
    } catch (error) {
    }
  }
  async addSkippedEntry(filePath, reason) {
    try {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file)
        return;
      const buffer = await this.app.vault.readBinary(file);
      const uint8Buffer = new Uint8Array(buffer);
      const md5 = crypto.createHash("md5").update(uint8Buffer).digest("hex");
      const entry = {
        md5,
        mtime: file.stat.mtime,
        timestamp: Date.now(),
        skipped: true,
        reason,
        originalSize: file.stat.size // Preserve size for skipped files as well
      };
      this.cacheData.entries[filePath] = entry;
      await this.saveCache();
    } catch (error) {
    }
  }
  async clearCache() {
    this.cacheData.entries = {};
    await this.saveCache();
  }
  getCacheStats() {
    const total = Object.keys(this.cacheData.entries).length;
    const size = JSON.stringify(this.cacheData).length;
    return { total, size };
  }
  // Cache backup system
  createBackup() {
    try {
      if (!fs2.existsSync(this.cacheFile)) {
        return;
      }
      const cacheDir = path2.dirname(this.cacheFile);
      const backupDir = path2.join(cacheDir, "cache-backups");
      if (!fs2.existsSync(backupDir)) {
        fs2.mkdirSync(backupDir, { recursive: true });
      }
      const now = /* @__PURE__ */ new Date();
      const timestamp = now.toISOString().replace(/[:.]/g, "-").slice(0, 19);
      const randomSuffix = Math.floor(Math.random() * 1e3).toString().padStart(3, "0");
      const backupFile = path2.join(backupDir, `tinyLocal-cache-backup-${timestamp}-${randomSuffix}.json`);
      fs2.copyFileSync(this.cacheFile, backupFile);
      this.cleanupOldBackups(backupDir);
    } catch (error) {
    }
  }
  cleanupOldBackups(backupDir) {
    try {
      const files = fs2.readdirSync(backupDir).filter((file) => file.startsWith("tinyLocal-cache-backup-") && file.endsWith(".json")).map((file) => ({
        name: file,
        path: path2.join(backupDir, file),
        stat: fs2.statSync(path2.join(backupDir, file))
      })).sort((a, b) => b.stat.mtime.getTime() - a.stat.mtime.getTime());
      const filesToDelete = files.slice(10);
      for (const file of filesToDelete) {
        fs2.unlinkSync(file.path);
      }
    } catch (error) {
    }
  }
  // Enhanced restore-from-backup method
  async restoreFromBackup(backupFileName) {
    try {
      const backupDir = path2.join(path2.dirname(this.cacheFile), "cache-backups");
      let backupFile;
      if (backupFileName) {
        backupFile = path2.join(backupDir, backupFileName);
      } else {
        const files = fs2.readdirSync(backupDir).filter((file) => file.startsWith("tinyLocal-cache-backup-") && file.endsWith(".json")).map((file) => ({
          name: file,
          path: path2.join(backupDir, file),
          stat: fs2.statSync(path2.join(backupDir, file))
        })).sort((a, b) => b.stat.mtime.getTime() - a.stat.mtime.getTime());
        if (files.length === 0) {
          return false;
        }
        backupFile = files[0].path;
      }
      if (!fs2.existsSync(backupFile)) {
        return false;
      }
      this.createBackup();
      fs2.copyFileSync(backupFile, this.cacheFile);
      this.loadCacheSync();
      const now = Date.now();
      for (const [key, entry] of Object.entries(this.cacheData.entries)) {
        entry.timestamp = now;
      }
      await this.saveCache();
      return true;
    } catch (error) {
      console.error(getLogTag(this), "Backup restore error:", error);
      return false;
    }
  }
  getCacheFile() {
    return this.cacheFile;
  }
  getAvailableBackups() {
    try {
      const backupDir = path2.join(path2.dirname(this.cacheFile), "cache-backups");
      if (!fs2.existsSync(backupDir)) {
        return [];
      }
      const backups = fs2.readdirSync(backupDir).filter((file) => file.startsWith("tinyLocal-cache-backup-") && file.endsWith(".json")).sort().reverse();
      return backups;
    } catch (error) {
      return [];
    }
  }
  // Count ghost entries (files that no longer exist)
  async getGhostEntriesCount() {
    let ghostCount = 0;
    for (const [cacheKey, entry] of Object.entries(this.cacheData.entries)) {
      const filePath = cacheKey.split(":")[0];
      try {
        const adapter = this.app.vault.adapter;
        const basePath = adapter.path?.absolute || adapter.basePath || process.cwd();
        const fullPath = path2.join(basePath, filePath);
        if (!fs2.existsSync(fullPath)) {
          ghostCount++;
        }
      } catch (error) {
        ghostCount++;
      }
    }
    return ghostCount;
  }
  // Cleanup ghost entries from cache
  async cleanupGhostEntries() {
    this.createBackup();
    const entriesToRemove = [];
    for (const [cacheKey, entry] of Object.entries(this.cacheData.entries)) {
      const filePath = cacheKey.split(":")[0];
      try {
        const adapter = this.app.vault.adapter;
        const basePath = adapter.path?.absolute || adapter.basePath || process.cwd();
        const fullPath = path2.join(basePath, filePath);
        if (!fs2.existsSync(fullPath)) {
          entriesToRemove.push(cacheKey);
        }
      } catch (error) {
        entriesToRemove.push(cacheKey);
      }
    }
    for (const cacheKey of entriesToRemove) {
      delete this.cacheData.entries[cacheKey];
    }
    if (entriesToRemove.length > 0) {
      await this.saveCache();
    }
    return entriesToRemove.length;
  }
};

// main.ts
var ProgressModal = class extends import_obsidian2.Modal {
  constructor(app, title) {
    super(app);
    this.titleEl.setText(title);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("div", { text: t(this.app, "progress.processing"), cls: "tiny-local-progress-title" });
    this.statusElement = contentEl.createEl("div", {
      text: t(this.app, "progress.start"),
      cls: "tiny-local-progress-status"
    });
    const progressContainer = contentEl.createEl("div", { cls: "tiny-local-progress-container" });
    const progressBar = progressContainer.createEl("div", { cls: "tiny-local-progress-bar" });
    this.progressElement = progressBar.createEl("div", { cls: "tiny-local-progress-fill" });
    // Use adaptive CSS classes instead of inline styles
    contentEl.addClass("tiny-local-progress-modal");
  }
  updateProgress(current, total, status) {
    const percentage = total > 0 ? current / total * 100 : 0;
    this.progressElement.style.width = `${percentage}%`;
    this.statusElement.setText(`${status} (${current}/${total})`);
    
    // Force UI update
    this.progressElement.style.transition = 'width 0.3s ease';
    requestAnimationFrame(() => {
      this.progressElement.style.width = `${percentage}%`;
    });
  }
  setCompleted(message) {
    this.statusElement.setText(message);
    this.progressElement.style.width = "100%";
    this.progressElement.classList.add("tiny-local-progress-completed");
    setTimeout(() => this.close(), 2e3);
  }
  setError(message) {
    this.statusElement.setText(message);
    this.progressElement.classList.add("tiny-local-progress-error");
    setTimeout(() => this.close(), 3e3);
  }
  onClose() {
    // Remove classes on close
    if (this.progressElement) {
      this.progressElement.classList.remove("tiny-local-progress-completed", "tiny-local-progress-error");
    }
  }
};
var TinyLocal = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.AUTO_COMPRESS_DELAY = 3e3;
    this.MIN_FILE_SIZE = 1024;
    // 1KB
    this.SUPPORTED_IMAGE_EXTENSIONS = ["png", "jpg", "jpeg"];
    // New settings for automatic compression
    this.AUTO_BACKGROUND_THRESHOLD = 50; // Will be updated after settings load
    // Trigger when >50 uncompressed (configurable)
    this.USER_INACTIVITY_THRESHOLD = 2 * 60 * 1e3;
    // 2 minutes of inactivity
    this.INACTIVITY_CHECK_INTERVAL = 5 * 60 * 1e3;
    // Check every 5 minutes
    this.lastUserActivity = Date.now();
    this.isBackgroundCompressionRunning = false;
    this.inactivityTimer = null;
    this._openStatusMenu = null;
    this._teardownStatusMenuListeners = null;
    if (!TinyLocal.currentLang) TinyLocal.currentLang = "en";
  }
  // ========================================================================
  // LIFECYCLE METHODS
  // ========================================================================
  async onload() {
    // Wait for layout readiness to get stable locale from vault config
    this.app.workspace.onLayoutReady(() => {
      TinyLocal.currentLang = getCurrentLang(this.app);
      // Re-render settings if opened, refresh status bar text
      try { this.updateSavingsIndicatorInSettings?.(); } catch (_) { try { console.debug(getLogTag(this), 'settings rerender after cache update failed (non-critical)'); } catch {} }
      this.updateStatusBar?.();
    });
    await this.initializePlugin();
    this.setupEventListeners();
    this.registerCommands();
    this.addSettingTab(new SettingsTab(this.app, this));
    await this.setupStatusBar();
    this.setupThemeAdaptation();
  }
  onunload() {
    if (this.inactivityTimer) {
      clearTimeout(this.inactivityTimer);
      this.inactivityTimer = null;
    }
  }
  
  // ========================================================================
  // VERSION CHECKING
  // ========================================================================
  async checkBinaryVersions() {
    try {
      const [pngquantVersion, mozjpegVersion] = await Promise.all([
        this.getCurrentPngquantVersion(),
        this.getCurrentMozjpegVersion()
      ]);
      return {
        pngquant: {
          current: pngquantVersion,
          latest: null,
          needsUpdate: false
        },
        mozjpeg: {
          current: mozjpegVersion,
          latest: null,
          needsUpdate: false
        }
      };
    } catch (error) {
      console.error(getLogTag(this), "Version check error:", error);
      return {
        pngquant: { current: null, latest: null, needsUpdate: false },
        mozjpeg: { current: null, latest: null, needsUpdate: false }
      };
    }
  }
  
  async getCurrentPngquantVersion() {
    try {
      const fs = require('fs');
      const path = require('path');
      const packagePath = path.join(this.getPluginDirectory(), 'node_modules', 'pngquant-bin', 'package.json');
      const packageData = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
      return packageData.version || null;
    } catch (error) {
      console.error(getLogTag(this), "pngquant version fetch error:", error.message);
      return null;
    }
  }
  
  async getCurrentMozjpegVersion() {
    try {
      const fs = require('fs');
      const path = require('path');
      const packagePath = path.join(this.getPluginDirectory(), 'node_modules', 'mozjpeg', 'package.json');
      const packageData = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
      return packageData.version || null;
    } catch (error) {
      console.error(getLogTag(this), "mozjpeg version fetch error:", error.message);
      return null;
    }
  }
  
  // Removed remote latest-version checks — only show currently found ones
  
  // ========================================================================
  // INITIALIZATION
  // ========================================================================
  async initializePlugin() {
    await this.loadSettings();
    // React to locale changes in vault config
    this.registerEvent(
      this.app.vault.on('config-changed', () => {
        const next = getCurrentLang(this.app);
        if (next !== TinyLocal.currentLang) {
          TinyLocal.currentLang = next;
          try { this.updateSavingsIndicatorInSettings?.(); } catch (_) { try { console.debug(getLogTag(this), 'settings rerender after lang switch failed (non-critical)'); } catch {} }
          this.updateStatusBar?.();
        }
      })
    );
    // Update background compression threshold after loading settings
    this.AUTO_BACKGROUND_THRESHOLD = this.settings.autoBackgroundThreshold || 50;
    // Migrate data from old id (tiny-local) to new one (local-image-compress)
    try {
      const configDir = this.app.vault.configDir;
      const adapter = this.app.vault.adapter;
      const basePath = adapter.path?.absolute || adapter.basePath || process.cwd();
      const oldDir = `${basePath}/${configDir}/plugins/tiny-local`.replace(/\\/g, "/");
      const newDir = `${basePath}/${configDir}/plugins/local-image-compress`.replace(/\\/g, "/");
      if (fs3.existsSync(oldDir)) {
        if (!fs3.existsSync(newDir)) fs3.mkdirSync(newDir, { recursive: true });
        const itemsToMove = [
          "tinyLocal-cache.json",
          "cache-backups",
          "original-files-backups"
        ];
        for (const item of itemsToMove) {
          try {
            const src = path3.join(oldDir, item);
            const dest = path3.join(newDir, item);
            if (fs3.existsSync(src) && !fs3.existsSync(dest)) {
              // Try to rename (fast). If it fails — copy recursively
              try {
                fs3.renameSync(src, dest);
              } catch (_) {
                const copyRecursive = (s, d) => {
                  const stat = fs3.statSync(s);
                  if (stat.isDirectory()) {
                    if (!fs3.existsSync(d)) fs3.mkdirSync(d, { recursive: true });
                    for (const entry of fs3.readdirSync(s)) {
                      copyRecursive(path3.join(s, entry), path3.join(d, entry));
                    }
                  } else {
                    fs3.copyFileSync(s, d);
                  }
                };
                copyRecursive(src, dest);
              }
            }
          } catch (e) {
            console.error(getLogTag(this), 'Migration item error', item, e);
          }
        }
      }
    } catch (e) {
      console.error(getLogTag(this), 'Startup migration error:', e);
    }
    this.cache = new Cache(this.app);
    this.compressor = new Compressor(this.getPluginDirectory(), this.settings);
    // Auto-clean ghost entries on start if enabled in settings
    if (this.settings.autoCleanupGhostsOnStart) {
      try {
        await this.cleanupGhostEntries();
      } catch (e) {
        console.error(getLogTag(this), 'Startup ghost cleanup error:', e);
      }
    }
    // Auto-clean backups by retention period on start
    try {
      const pluginDir = this.getPluginDirectory();
      const backupDir = path3.join(pluginDir, 'original-files-backups');
      if (this.settings.autoBackupsRetentionEnabled) {
        await this.applyBackupsRetention(backupDir);
      }
    } catch (e) {
      console.error(getLogTag(this), 'Startup backups cleanup error:', e);
    }

    // Auto-move compressed files by threshold on start
    if (this.settings.autoMoveCompressedEnabled) {
      try {
        await this.tryAutoMoveCompressed();
      } catch (e) {
        console.error(getLogTag(this), 'Startup auto-move error:', e);
      }
    }
  }

  async tryAutoMoveCompressed() {
    try {
      const count = await this.getCompressedFilesCount();
      if (count >= (this.settings.autoMoveCompressedThreshold || 1)) {
        await this.moveCompressedToFiles();
      }
    } catch (e) {
      console.error(getLogTag(this), 'tryAutoMoveCompressed error:', e);
    }
  }
  getPluginDirectory() {
    const manifestDir = this.manifest.dir;
    const configDir = this.app.vault.configDir;
    const adapter = this.app.vault.adapter;
    const basePath = adapter.path?.absolute || adapter.basePath || process.cwd();
    if (manifestDir) {
      return manifestDir.startsWith("/") || manifestDir.includes(":") ? manifestDir : `${basePath}/${manifestDir}`.replace(/\\/g, "/");
    }
    return `${basePath}/${configDir}/plugins/local-image-compress`.replace(/\\/g, "/");
  }
  setupEventListeners() {
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (file instanceof import_obsidian2.TFile) {
          this.addContextMenu(menu, file);
        } else if (file instanceof import_obsidian2.TFolder) {
          this.addFolderContextMenu(menu, file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("create", async (file) => {
        await this.updateStatusBar();
        await this.handleNewFile(file);
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", async () => await this.updateStatusBar())
    );
    this.registerEvent(
      this.app.vault.on("rename", async () => await this.updateStatusBar())
    );
    this.setupUserActivityTracking();
    this.startInactivityCheck();
  }
  // Track user activity
  setupUserActivityTracking() {
    const updateActivity = () => {
      this.lastUserActivity = Date.now();
    };
    document.addEventListener("mousemove", updateActivity, { passive: true });
    document.addEventListener("keydown", updateActivity, { passive: true });
    document.addEventListener("click", updateActivity, { passive: true });
    document.addEventListener("scroll", updateActivity, { passive: true });
    this.registerEvent(
      this.app.workspace.on("file-open", updateActivity)
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", updateActivity)
    );
  }
  // Check user inactivity
  isUserInactive() {
    const timeSinceLastActivity = Date.now() - this.lastUserActivity;
    return timeSinceLastActivity > this.USER_INACTIVITY_THRESHOLD;
  }
  // Start inactivity interval
  startInactivityCheck() {
    const checkInactivity = async () => {
      if (this.settings.autoBackgroundCompression && this.isUserInactive()) {
        await this.checkAndStartBackgroundCompression();
      }
      this.inactivityTimer = setTimeout(checkInactivity, this.INACTIVITY_CHECK_INTERVAL);
    };
    this.inactivityTimer = setTimeout(checkInactivity, this.INACTIVITY_CHECK_INTERVAL);
  }
  // Evaluate conditions and start background compression
  async checkAndStartBackgroundCompression() {
    if (!this.isUserInactive()) {
      return;
    }
    const uncompressedCount = await this.getUncompressedImagesCount();
    if (uncompressedCount > this.AUTO_BACKGROUND_THRESHOLD) {
      await this.startBackgroundCompression();
    }
  }
  // Background compression without notices
  async startBackgroundCompression() {
    if (this.isBackgroundCompressionRunning) {
      return;
    }
    this.isBackgroundCompressionRunning = true;
    try {
      const imageFiles = await this.getImageFiles();
      const filteredFiles = imageFiles.filter(
        (file) => this.isImageFile(file) && this.isAllowedPath(file.path)
      );
      const uncompressedFiles = [];
      for (const file of filteredFiles) {
        if (!await this.cache.isFileAlreadyCompressed(file.path)) {
          uncompressedFiles.push(file);
        }
      }
      await this.processBatchCompressionBackground(uncompressedFiles);
    } catch (error) {
      console.error(getLogTag(this), "Background compression error:", error);
    } finally {
      this.isBackgroundCompressionRunning = false;
      await this.updateStatusBar();
    }
  }
  // Batch compression in background (no modal)
  async processBatchCompressionBackground(files) {
    await this.withPluginsDisabled(
      ["obsidian-paste-image-rename"],
      async () => {
        let compressed = 0;
        let processed = 0;
        let skippedAlreadyCompressed = 0;
        let skippedValidation = 0;
        let skippedErrors = 0;
        for (const file of files) {
          try {
            processed++;
            const isAlreadyCompressed = await this.cache.isFileAlreadyCompressed(file.path);
            if (isAlreadyCompressed) {
              skippedAlreadyCompressed++;
              continue;
            }
            const validation = await this.validateFileForCompression(file);
            if (!validation.valid) {
              skippedValidation++;
              continue;
            }
            const result = await this.compressor.compress(file, this.settings);
            if (result.success) {
              compressed++;
              const cacheKey = await this.cache.getCacheKey(file);
              // Store original file size in cache
              await this.cache.addToCache(cacheKey, file.stat.size);
              await this.updateStatusBar();
            } else {
              skippedErrors++;
            }
          } catch (error) {
            console.error(getLogTag(this), `Error: ${file.name}`, error);
            skippedErrors++;
          }
        }

        if (compressed > 0) {
          this.cache.createBackup();
          // Update savings indicator in settings
          this.updateSavingsIndicatorInSettings();
        }
      }
    );
  }
  async handleNewFile(file) {
    if (!this.settings.autoCompressNewFiles || !(file instanceof import_obsidian2.TFile) || !this.isImageFile(file)) {
      return;
    }
    setTimeout(async () => {
      await this.autoCompressNewFile(file);
    }, this.AUTO_COMPRESS_DELAY);
  }
  async setupStatusBar() {
    this.statusBarItem = this.addStatusBarItem();
    await this.updateStatusBar();
  }
  // ========================================================================
  // SETTINGS MANAGEMENT
  // ========================================================================
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // ========================================================================
  // COMMAND REGISTRATION
  // ========================================================================
  registerCommands() {
    const commands = [
      {
        id: "compress-images-in-note",
        name: t(this.app, "command.compressInNote"),
        callback: () => this.compressImagesInNote()
      },
      {
        id: "compress-images-in-folder",
        name: t(this.app, "command.compressInFolder"),
        callback: () => this.compressImagesInFolder()
      },
      {
        id: "compress-all-images",
        name: t(this.app, "command.compressAll"),
        callback: () => this.compressAllImages()
      },
      {
        id: "move-compressed-to-files",
        name: t(this.app, "command.moveCompressed"),
        callback: () => this.moveCompressedToFiles()
      }
    ];
    commands.forEach((cmd) => this.addCommand(cmd));
  }
  // ========================================================================
  // CONTEXT MENU
  // ========================================================================
  addContextMenu(menu, file) {
    if (!this.isImageFile(file))
      return;
    menu.addItem((item) => {
      item.setTitle(t(this.app, "context.compressImage")).setIcon("compress").onClick(() => this.compressFile(file));
    });
  }
  addFolderContextMenu(menu, folder) {
    if (isInsideOutputFolder(folder.path, this.settings.outputFolder))
      return;
    menu.addItem((item) => {
      item.setTitle(t(this.app, "context.compressImagesInFolder")).setIcon("images").onClick(() => this.compressImagesInFolderPath(folder.path));
    });
  }
  // ========================================================================
  // UTILITY METHODS
  // ========================================================================
  isImageFile(file) {
    return this.SUPPORTED_IMAGE_EXTENSIONS.includes(file.extension.toLowerCase());
  }
  async isImageFileAndNotCompressed(file) {
    if (!this.isImageFile(file)) {
      return false;
    }
    const isInOutputFolder = isInsideOutputFolder(file.path, this.settings.outputFolder);
    if (isInOutputFolder) {
      return false;
    }
    const isAlreadyCompressed = await this.cache.isFileAlreadyCompressed(file.path);
    return !isAlreadyCompressed;
  }
  // Get ALL images (no cache pre-filtering, as in older version)
  getAllImageFiles() {
    const allFiles = this.app.vault.getFiles();
    const outputFolder = this.settings.outputFolder;
    
    // Optimization: use Array.filter instead of manual loop
    return allFiles.filter(file => {
      if (!this.isImageFile(file)) {
        return false;
      }
      
      // Ensure file is not inside the compressed files folder
      const pathParts = file.path.split("/");
      return !pathParts.includes(outputFolder);
    });
  }
  async getImageFiles() {
    const allFiles = this.app.vault.getFiles();
    
    // Optimization: first filter by file type, then consult cache
    const imageFiles = allFiles.filter(file => this.isImageFile(file));
    
    const result = [];
    for (const file of imageFiles) {
      if (await this.isImageFileAndNotCompressed(file)) {
        result.push(file);
      }
    }
    return result;
  }
  isAllowedPath(filePath) {
    if (!this.settings.allowedRoots?.length) {
      return true;
    }
    const isAllowed = this.settings.allowedRoots.some((root) => filePath.startsWith(root));
    return isAllowed;
  }
  // ========================================================================
  // PLUGIN DISABLE/ENABLE UTILITY
  // ========================================================================
  async withPluginsDisabled(pluginIds, task) {
    const disabled = [];
    try {
      for (const id of pluginIds) {
        if (this.app.plugins?.enabledPlugins?.has(id)) {
          await this.app.plugins.disablePlugin(id);
          disabled.push(id);
        }
      }
      return await task();
    } finally {
      for (const id of disabled) {
        try {
          await this.app.plugins.enablePlugin(id);
        } catch (error) {
          console.error(getLogTag(this), `Error enabling plugin ${id}:`, error);
        }
      }
    }
  }
  // ========================================================================
  // VALIDATION
  // ========================================================================
  async validateFileForCompression(file) {
    if (!this.isAllowedPath(file.path)) {
      return { valid: false, error: "\u041F\u0443\u0442\u044C \u043D\u0435 \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043D \u0432 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u0445" };
    }
    const isAlreadyCompressed = await this.cache.isFileAlreadyCompressed(file.path);
    if (isAlreadyCompressed) {
      return { valid: false, error: "\u0424\u0430\u0439\u043B \u0443\u0436\u0435 \u0441\u0436\u0430\u0442" };
    }
    const minSize = file.extension.toLowerCase() === "png" ? 5 * 1024 : 10 * 1024;
    if (file.stat.size < minSize) {
      await this.cache.addSkippedEntry(file.path, "too_small");
      return { valid: false, error: `\u0424\u0430\u0439\u043B \u0441\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u0438\u0439 (${file.stat.size} \u0431\u0430\u0439\u0442)`, skipped: true };
    }
    return { valid: true };
  }
  // ========================================================================
  // COMPRESSION METHODS
  // ========================================================================
  async compressFile(file) {
    await this.withPluginsDisabled(
      ["obsidian-paste-image-rename"],
      async () => {
        try {
          const validation = await this.validateFileForCompression(file);
          if (!validation.valid) {
            if (validation.skipped) {
              return;
            } else {
              new import_obsidian2.Notice(`${getPluginName(this)}: ${validation.error}`);
              return;
            }
          }
          const result = await this.compressor.compress(file, this.settings);
          if (result.success) {
            await this.handleSuccessfulCompression(file, result.savings);
          } else {
            new import_obsidian2.Notice(`${getPluginName(this)}: ${result.error}`);
          }
        } catch (error) {
          new import_obsidian2.Notice(`${getPluginName(this)}: ${t(this.app, "notice.cacheCleared")}`);
        }
      }
    );
  }
  async handleSuccessfulCompression(file, savings) {
    const cacheKey = await this.cache.getCacheKey(file);
    // Store original file size in cache
    await this.cache.addToCache(cacheKey, file.stat.size);
    this.cache.createBackup();
    await this.updateStatusBar();
    
    // Update savings indicator in settings if settings tab is open
    this.updateSavingsIndicatorInSettings();
    
    if (savings) {
      new import_obsidian2.Notice(`${getPluginName(this)}: ${Math.round(savings)}%`);
    } else {
      new import_obsidian2.Notice(`${getPluginName(this)}: ${t(this.app, "notice.cacheUpdated")}`);
    }
  }
  async autoCompressNewFile(file) {
    await this.withPluginsDisabled(
      ["obsidian-paste-image-rename"],
      async () => {
        try {
          const validation = await this.validateFileForCompression(file);
          if (!validation.valid) {
            return;
          }
          const result = await this.compressor.compress(file, this.settings);
          if (result.success) {
            await this.handleSuccessfulCompression(file, result.savings);
          }
        } catch (error) {
          console.error(getLogTag(this), "Auto-compression error:", error);
        }
      }
    );
  }
  // ========================================================================
  // BATCH COMPRESSION METHODS
  // ========================================================================
  async compressImagesInNote() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian2.Notice(`${getPluginName(this)}: ${t(this.app, "command.compressInNote")}`);
      return;
    }
    const images = await this.getImagesInNote(activeFile);
    if (images.length === 0) {
      new import_obsidian2.Notice(`${getPluginName(this)}: ${t(this.app, "stats.uncompressed.name")}`);
      return;
    }
    await this.processBatchCompression(images, t(this.app, "command.compressInNote"));
  }
  async compressImagesInFolder() {
    const folders = this.app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian2.TFolder);
    if (folders.length === 0) {
      new import_obsidian2.Notice(`${getPluginName(this)}: ${t(this.app, "folders.noneInVault")}`);
      return;
    }
    const folderPaths = folders.map((folder) => folder.path).filter((path4) => path4 !== "");
    folderPaths.unshift("/");
    const selectedPath = await this.showFolderSelector(folderPaths);
    if (selectedPath === null)
      return;
    await this.compressImagesInFolderPath(selectedPath);
  }
  async compressAllImages() {
    await this.compressImagesInFolderPath("/", true);
  }
  async processBatchCompression(files, title) {
    await this.withPluginsDisabled(
      ["obsidian-paste-image-rename"],
      async () => {
        const progressModal = new ProgressModal(this.app, title);
        progressModal.open();
        progressModal.updateProgress(0, files.length, t(this.app, "progress.start"));
        let compressed = 0;
        let processed = 0;
        let skippedAlreadyCompressed = 0;
        let skippedValidation = 0;
        let skippedErrors = 0;
        for (const file of files) {
          try {
            processed++;
            progressModal.updateProgress(processed, files.length, `${t(this.app, "progress.processing")}: ${file.name}`);
            const isAlreadyCompressed = await this.cache.isFileAlreadyCompressed(file.path);
            if (isAlreadyCompressed) {
              progressModal.updateProgress(processed, files.length, `${t(this.app, "progress.skippedAlready")}: ${file.name}`);
              skippedAlreadyCompressed++;
              continue;
            }
            const validation = await this.validateFileForCompression(file);
            if (!validation.valid) {
              progressModal.updateProgress(processed, files.length, `${t(this.app, "progress.skipped")}: ${file.name}`);
              skippedValidation++;
              continue;
            }
            const result = await this.compressor.compress(file, this.settings);
            if (result.success) {
              compressed++;
              progressModal.updateProgress(processed, files.length, `${t(this.app, "progress.compressed")} (${result.savings}%): ${file.name}`);
              const cacheKey = await this.cache.getCacheKey(file);
              // Store original file size in cache
              await this.cache.addToCache(cacheKey, file.stat.size);
            } else {
              progressModal.updateProgress(processed, files.length, `${t(this.app, "progress.skipped")}: ${file.name}`);
              skippedErrors++;
            }
          } catch (error) {
            progressModal.updateProgress(processed, files.length, `${t(this.app, "progress.error")}: ${file.name}`);
            skippedErrors++;
          }
        }
        progressModal.setCompleted(`${t(this.app, "progress.completed")} ${compressed}/${files.length}`);
        if (compressed > 0) {
          this.cache.createBackup();
          // Update savings indicator in settings
          this.updateSavingsIndicatorInSettings();
        }
      }
    );
    await this.updateStatusBar();
  }
  // ========================================================================
  // FOLDER SELECTION
  // ========================================================================
  async showFolderSelector(folderPaths) {
    return new Promise((resolve2) => {
      const overlay = document.createElement("div");
      overlay.className = "modal-container";

      const dialog = document.createElement("div");
      dialog.className = "modal";
      overlay.appendChild(dialog);

      const header = document.createElement("div");
      header.className = "modal-header";
      const title = document.createElement("h3");
      title.textContent = t(this.app, "folderSelect.title") || "Select a folder for image compression";
      header.appendChild(title);
      dialog.appendChild(header);

      const content = document.createElement("div");
      content.className = "modal-content";
      const select = document.createElement("select");
      select.style.width = "100%";
      select.style.padding = "8px";
      select.style.margin = "10px 0";
      for (const p of folderPaths) {
        const option = document.createElement("option");
        option.value = p;
        option.textContent = p === "/" ? (t(this.app, "folderSelect.root") || t(this.app, "folders.root") || "Vault root") : p;
        select.appendChild(option);
      }
      content.appendChild(select);
      dialog.appendChild(content);

      const footer = document.createElement("div");
      footer.className = "modal-footer";
      const okBtn = document.createElement("button");
      okBtn.id = "select-folder";
      okBtn.className = "mod-cta";
      okBtn.textContent = t(this.app, "folderSelect.select") || t(this.app, "common.select") || "Select";
      const cancelBtn = document.createElement("button");
      cancelBtn.id = "cancel-folder";
      cancelBtn.textContent = t(this.app, "folderSelect.cancel") || t(this.app, "common.cancel") || "Cancel";
      footer.appendChild(okBtn);
      footer.appendChild(cancelBtn);
      dialog.appendChild(footer);

      document.body.appendChild(overlay);

      const cleanup = () => {
        if (document.body.contains(overlay)) {
          document.body.removeChild(overlay);
        }
      };

      okBtn.addEventListener("click", () => {
        resolve2(select.value);
        cleanup();
      });
      cancelBtn.addEventListener("click", () => {
        resolve2(null);
        cleanup();
      });
      overlay.addEventListener("click", (e) => {
        if (e.target === overlay) {
          resolve2(null);
          cleanup();
        }
      });

      // Keyboard accessibility
      overlay.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          resolve2(null);
          cleanup();
        } else if (e.key === "Enter") {
          resolve2(select.value);
          cleanup();
        }
      });
      // Focus management
      setTimeout(() => select.focus(), 0);
    });
  }
  async compressImagesInFolderPath(folderPath, isRecursive = false) {
    const allFiles = this.app.vault.getFiles();
    let targetFiles;
    if (folderPath === "/") {
      targetFiles = allFiles;
    } else {
      targetFiles = allFiles.filter((file) => {
        if (isRecursive) {
          return file.path.startsWith(folderPath + "/") || file.path.startsWith(folderPath);
        } else {
          const fileFolderPath = file.path.substring(0, file.path.lastIndexOf("/"));
          return fileFolderPath === folderPath;
        }
      });
    }
    const imageFiles = [];
    for (const file of targetFiles) {
      if (await this.isImageFileAndNotCompressed(file)) {
        imageFiles.push(file);
      }
    }
    if (imageFiles.length === 0) {
      new import_obsidian2.Notice(`${this.manifest?.name || "Local Image Compress"}: ${t(this.app, "stats.uncompressed.name")}`);
      return;
    }
    await this.processBatchCompression(imageFiles, t(this.app, "command.compressAll"));
  }
  // ========================================================================
  // IMAGE DETECTION
  // ========================================================================
  async getImagesInNote(file) {
    try {
      const content = await this.app.vault.read(file);
      const imageRegex = /!\[\[([^\]]+\.(png|jpg|jpeg|gif|bmp|webp))\]\]/gi;
      const matches = content.match(imageRegex);
      if (!matches)
        return [];
      const imageFiles = [];
      const allFiles = this.app.vault.getFiles();
      for (const match of matches) {
        const fileName = match.replace(/!\[\[([^\]]+)\]\]/g, "$1");
        const imageFile = this.app.vault.getAbstractFileByPath(fileName);
        if (imageFile instanceof import_obsidian2.TFile && this.isImageFile(imageFile)) {
          imageFiles.push(imageFile);
          continue;
        }
        const foundFile = allFiles.find(
          (f) => f.name === fileName || f.path.endsWith(fileName) || f.path.endsWith("/" + fileName)
        );
        if (foundFile && this.isImageFile(foundFile)) {
          imageFiles.push(foundFile);
        }
      }
      return imageFiles;
    } catch (error) {
      return [];
    }
  }
  // ========================================================================
  // STATISTICS
  // ========================================================================
  async getTotalImagesCount() {
    const imageFiles = this.getAllImageFiles();
    return imageFiles.length;
  }
  async getUncompressedImagesCount() {
    const imageFiles = this.getAllImageFiles();
    let count = 0;
    for (const file of imageFiles) {
      if (!await this.cache.isFileAlreadyCompressed(file.path)) {
        count++;
      }
    }
    return count;
  }
  
  // ========================================================================
  // SPACE SAVINGS CALCULATION
  // ========================================================================
  
  // File size thresholds
  static FILE_SIZE_THRESHOLDS = {
    KB_100: 100 * 1024,
    KB_200: 200 * 1024,
    KB_500: 500 * 1024,
    MB_1: 1024 * 1024
  };
  
  // Compression ratio constants
  static COMPRESSION_RATIOS = {
    PNG_SMALL: 2.5,    // < 100KB: ~60% compression
    PNG_MEDIUM: 2.0,   // 100KB - 1MB: ~50% compression
    PNG_LARGE: 1.8,    // > 1MB: ~45% compression
    JPEG_SMALL: 1.4,   // < 500KB: ~30% compression
    JPEG_LARGE: 1.3,   // > 500KB: ~25% compression
    WEBP_SMALL: 2.0,   // < 200KB: ~50% compression
    WEBP_LARGE: 1.7,   // > 200KB: ~40% compression
    DEFAULT: 1.5       // Average ratio for other formats
  };
  async calculateSpaceSavings() {
    try {
      const allFiles = this.getAllImageFiles();
      if (allFiles.length === 0) {
        return this.getEmptySavingsResult();
      }

      let originalSize = 0;
      let currentSize = 0;
      let processedFiles = 0;
      let filesWithExactData = 0;
      let estimatedFiles = 0;
      
      // Process files in batches for better performance
      const batchSize = 50;
      for (let i = 0; i < allFiles.length; i += batchSize) {
        const batch = allFiles.slice(i, i + batchSize);
        
        for (const file of batch) {
          const fileSize = file.stat.size;
          const isCompressed = await this.cache.isFileAlreadyCompressed(file.path);

          if (isCompressed) {
            // Prefer exact original size from cache when available
            const cachedOriginalSize = await this.getCachedOriginalSize(file.path);

            // Current size: if not yet moved, take size from Compressed folder
            const compressedPath = this.getCompressedFilePath(file.path);
            const compressedSize = await this.getCompressedFileSize(compressedPath);
            const current = compressedSize > 0 ? compressedSize : fileSize;

            if (cachedOriginalSize && cachedOriginalSize > 0) {
              originalSize += cachedOriginalSize;
              currentSize += current;
              filesWithExactData++;
            } else {
              // Estimate original size: if compressed size exists, infer from it
              const estimatedOriginalSize = compressedSize > 0
                ? this.estimateOriginalSizeFromCurrent({ stat: { size: compressedSize }, extension: file.extension })
                : this.estimateOriginalSizeFromCurrent(file);
              originalSize += estimatedOriginalSize;
              currentSize += current;
              estimatedFiles++;
            }
            processedFiles++; // Count cached entries as processed
          } else {
            // Uncompressed files: original = current
            originalSize += fileSize;
            currentSize += fileSize;
          }
        }
        
        // Small pause between batches to prevent UI blocking
        if (i + batchSize < allFiles.length) {
          await new Promise(resolve => setTimeout(resolve, 1));
        }
      }
      
      // Show stats when there are files with exact OR estimated data
      if (filesWithExactData === 0 && estimatedFiles === 0) {
        return this.getEmptySavingsResult(allFiles.length);
      }
      
      const savedSize = Math.max(0, originalSize - currentSize);
      const savedPercentage = originalSize > 0 ? Math.round((savedSize / originalSize) * 100) : 0;
      
      return {
        originalSize,
        currentSize,
        savedSize,
        savedPercentage,
        processedFiles,
        totalFiles: allFiles.length,
        estimatedFiles
      };
    } catch (error) {
      console.error(getLogTag(this), "Space savings calculation error:", error);
      return this.getEmptySavingsResult();
    }
  }

  getEmptySavingsResult(totalFiles = 0) {
    return {
      originalSize: 0,
      currentSize: 0,
      savedSize: 0,
      savedPercentage: 0,
      processedFiles: 0,
      totalFiles,
      estimatedFiles: 0
    };
  }

  validateSavingsData(savings) {
    return savings && 
           typeof savings.processedFiles === 'number' && 
           typeof savings.savedSize === 'number' && 
           typeof savings.originalSize === 'number' &&
           typeof savings.currentSize === 'number' &&
           typeof savings.savedPercentage === 'number' &&
           typeof savings.totalFiles === 'number' &&
           typeof savings.estimatedFiles === 'number' &&
           savings.processedFiles > 0 && 
           savings.savedSize > 0 &&
           savings.originalSize >= 0 &&
           savings.currentSize >= 0 &&
           savings.savedPercentage >= 0 &&
           savings.totalFiles >= 0 &&
           savings.estimatedFiles >= 0;
  }

  estimateOriginalSizeFromCurrent(file) {
    try {
      if (!file || !file.stat || typeof file.stat.size !== 'number') {
        return 0;
      }
      
      const currentSize = file.stat.size;
      const extension = (file.extension || '').toLowerCase();
      
      // Derive compression ratio based on format and size
      const compressionRatio = this.getCompressionRatio(extension, currentSize, TinyLocal.FILE_SIZE_THRESHOLDS);
      
      const estimatedSize = Math.round(currentSize * compressionRatio);
      
      // Guard against unrealistic values
      if (estimatedSize <= 0 || estimatedSize > currentSize * 10) {
        return currentSize; // Fallback to current size
      }
      
      return estimatedSize;
    } catch (error) {
      console.error(getLogTag(this), "Original size estimation error:", error);
      return file.stat.size; // Fallback to current size
    }
  }

  getCompressionRatio(extension, currentSize, sizes) {
    const { KB_100, KB_200, KB_500, MB_1 } = sizes;
    const ratios = TinyLocal.COMPRESSION_RATIOS;
    
    switch (extension) {
      case 'png':
        if (currentSize < KB_100) return ratios.PNG_SMALL;
        if (currentSize < MB_1) return ratios.PNG_MEDIUM;
        return ratios.PNG_LARGE;
        
      case 'jpg':
      case 'jpeg':
        if (currentSize < KB_500) return ratios.JPEG_SMALL;
        return ratios.JPEG_LARGE;
        
      case 'webp':
        if (currentSize < KB_200) return ratios.WEBP_SMALL;
        return ratios.WEBP_LARGE;
        
      default:
        return ratios.DEFAULT;
    }
  }

  formatTooltipData(savings) {
    if (!savings) {
      return {
        originalFormatted: '0 B',
        currentFormatted: '0 B',
        savedFormatted: '0 B',
        estimatedIndicator: '',
        estimatedText: ''
      };
    }
    
    const originalFormatted = this.formatFileSize(savings.originalSize || 0);
    const currentFormatted = this.formatFileSize(savings.currentSize || 0);
    const savedFormatted = this.formatFileSize(savings.savedSize || 0);
    const estimatedIndicator = (savings.estimatedFiles || 0) > 0 ? ' ~' : '';
    const estimatedText = (savings.estimatedFiles || 0) > 0 ? ` (${savings.estimatedFiles} оценено)` : '';
    
    return {
      originalFormatted,
      currentFormatted,
      savedFormatted,
      estimatedIndicator,
      estimatedText
    };
  }
  
  async getCachedOriginalSize(filePath) {
    try {
      if (!filePath || !this.cache || !this.cache.cacheData || !this.cache.cacheData.entries) {
        return null;
      }
      
      // Look up original size in cache
      const entries = this.cache.cacheData.entries;
      const cacheKeys = Object.keys(entries);
      
      // Use a more efficient search
      for (const cacheKey of cacheKeys) {
        const keyPath = cacheKey.split(":")[0];
        if (keyPath === filePath) {
          const entry = entries[cacheKey];
          if (entry && entry.originalSize && typeof entry.originalSize === 'number' && entry.originalSize > 0) {
            return entry.originalSize;
          }
        }
      }
      return null;
    } catch (error) {
      console.error(getLogTag(this), "Error getting original size from cache:", error);
      return null;
    }
  }
  

  
  getCompressedFilePath(originalPathOrVaultRelative) {
    const adapter = this.app.vault.adapter;
    const basePath = adapter.path?.absolute || adapter.basePath || process.cwd();
    // Support both absolute and vault-relative paths
    const isAbsolute = typeof originalPathOrVaultRelative === 'string' && (originalPathOrVaultRelative.startsWith('/') || originalPathOrVaultRelative.includes(':'));
    const vaultRelativePath = isAbsolute
      ? path3.relative(basePath, originalPathOrVaultRelative)
      : originalPathOrVaultRelative;
    return path3.join(basePath, this.settings.outputFolder, vaultRelativePath);
  }
  
  async getCompressedFileSize(compressedFilePath) {
    try {
      const fs = require('fs');
      if (fs.existsSync(compressedFilePath)) {
        const stats = fs.statSync(compressedFilePath);
        return stats.size;
      }
      return 0;
    } catch (error) {
      return 0;
    }
  }
  
  formatFileSize(bytes) {
    if (bytes === 0) return '0 B';
    
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
  }
  
  shouldShowSavingsIndicator() {
    // Show indicator only if there are compressed files with exact data
    return this.cache.getCacheStats().total > 0;
  }
  
  async hasValidSavingsData() {
    // Verify there are files with exact compression data
    try {
      const savings = await this.calculateSpaceSavings();
      return savings.processedFiles > 0 && savings.savedSize > 0;
    } catch (error) {
      return false;
    }
  }
  
  async updateSavingsIndicator() {
    // Method to update the indicator in settings
    // Actual rendering is handled in SettingsTab
    const savings = await this.calculateSpaceSavings();
    return savings;
  }
  
  updateSavingsIndicatorInSettings() {
    // Update savings indicator in settings
    try {
      const settingsTab = this.app.setting.openTabById(this.manifest?.id || 'local-image-compress');
      if (settingsTab && settingsTab.plugin === this) {
        // If the tab is rendering, mark as pending
        if (settingsTab._isRendering) {
          settingsTab._pendingRerender = true;
          return;
        }
        // Otherwise schedule a soft rerender
        requestAnimationFrame(() => settingsTab.display());
      }
    } catch (error) {
      console.error(getLogTag(this), "Settings indicator update error:", error);
    }
  }
  // Force refresh of cache and status bar
  async forceRefreshCache() {
    await this.cache.forceRefreshCache();
    await this.updateStatusBar();
  }
  // Get number of ghost entries in cache
  async getGhostEntriesCount() {
    return await this.cache.getGhostEntriesCount();
  }
  // Remove ghost entries from cache
  async cleanupGhostEntries() {
    const removedCount = await this.cache.cleanupGhostEntries();
    await this.updateStatusBar();
    return removedCount;
  }
  // ========================================================================
  // STATUS BAR
  // ========================================================================
  async updateStatusBar() {
    if (!this.statusBarItem) {
      return;
    }
    const [uncompressedCount, totalCount] = await Promise.all([
      this.getUncompressedImagesCount(),
      this.getTotalImagesCount()
    ]);
    if (totalCount > 0) {
      const statusText = this.isBackgroundCompressionRunning ? `${uncompressedCount} / ${totalCount} \u25CF` : `${uncompressedCount} / ${totalCount}`;
      this.statusBarItem.setText(statusText);
      this.statusBarItem.show();
      if (this.isBackgroundCompressionRunning) {
        this.statusBarItem.addClass("tiny-local-compressing");
      } else {
        this.statusBarItem.removeClass("tiny-local-compressing");
      }
      this.statusBarItem.onclick = async (event) => {
        event.preventDefault();
        await this.showStatusBarMenu(event);
      };
    } else {
      this.statusBarItem.hide();
    }
  }
  async showStatusBarMenu(event) {
    // Close previous menu if any
    if (this._openStatusMenu && document.body.contains(this._openStatusMenu)) {
      try { document.body.removeChild(this._openStatusMenu); } catch (_) { try { console.debug(getLogTag(this), 'status menu remove failed (non-critical)'); } catch {} }
    }
    if (typeof this._teardownStatusMenuListeners === 'function') {
      try { this._teardownStatusMenuListeners(); } catch (_) { try { console.debug(getLogTag(this), 'status menu teardown failed (non-critical)'); } catch {} }
    }

    const [uncompressedCount, totalCount] = await Promise.all([
      this.getUncompressedImagesCount(),
      this.getTotalImagesCount()
    ]);
    const menu = this.createStatusBarMenu(event, uncompressedCount, totalCount);
    document.body.appendChild(menu);

    // Attach listeners with centralized teardown
    const teardown = (() => {
      const onDocClick = (e) => {
        if (!menu.contains(e.target)) {
          cleanup();
        }
      };
      const onKeyDown = (e) => {
        if (e.key === 'Escape') {
          cleanup();
        }
      };
      const onBlur = () => cleanup();

      const cleanup = () => {
        document.removeEventListener('click', onDocClick);
        document.removeEventListener('keydown', onKeyDown);
        window.removeEventListener('blur', onBlur);
        if (document.body.contains(menu)) {
          try { document.body.removeChild(menu); } catch (_) { try { console.debug(getLogTag(this), 'status menu remove (hover) failed (non-critical)'); } catch {} }
        }
        if (this._openStatusMenu === menu) this._openStatusMenu = null;
        if (this._teardownStatusMenuListeners === cleanup) this._teardownStatusMenuListeners = null;
      };

      // Defer click binding to avoid immediate close due to the opening click
      setTimeout(() => document.addEventListener('click', onDocClick), 0);
      document.addEventListener('keydown', onKeyDown);
      window.addEventListener('blur', onBlur);
      return cleanup;
    })();

    this._openStatusMenu = menu;
    this._teardownStatusMenuListeners = teardown;
  }
  createStatusBarMenu(event, uncompressedCount, totalCount) {
    const menu = document.createElement("div");
    menu.className = "tiny-local-status-menu";
    const rect = event.target.getBoundingClientRect();
    const menuWidth = 200;
    const windowWidth = window.innerWidth;
    let left = rect.left;
    if (left + menuWidth > windowWidth) {
      left = windowWidth - menuWidth - 10;
    }
    menu.style.left = `${left}px`;
    menu.style.top = `${rect.top - 10}px`;
    menu.style.transform = "translateY(-100%)";
    const header = menu.createEl("div", {
      text: `${t(this.app, "stats.uncompressed.name")}: ${uncompressedCount} / ${totalCount}`,
      cls: "tiny-local-status-menu-header"
    });
    const menuItems = [
      { text: t(this.app, "command.compressInNote"), action: () => this.compressImagesInNote() },
      { text: t(this.app, "command.compressAll"), action: () => this.compressAllImages() }
    ];
    menuItems.forEach((item) => {
      const menuItem = menu.createEl("div", { 
        text: item.text,
        cls: "tiny-local-status-menu-item"
      });
      menuItem.addEventListener("mouseenter", () => {
        menuItem.classList.add("tiny-local-status-menu-item-hover");
      });
      menuItem.addEventListener("mouseleave", () => {
        menuItem.classList.remove("tiny-local-status-menu-item-hover");
      });
      menuItem.addEventListener("click", () => {
        item.action();
        if (document.body.contains(menu)) {
          document.body.removeChild(menu);
        }
      });
    });
    return menu;
  }
  setupMenuEventListeners(menu) {
    const closeMenu = (e) => {
      if (!menu.contains(e.target)) {
        if (document.body.contains(menu)) {
          document.body.removeChild(menu);
        }
        document.removeEventListener("click", closeMenu);
      }
    };
    setTimeout(() => {
      document.addEventListener("click", closeMenu);
    }, 100);
  }
  // ========================================================================
  // BACKUP MANAGEMENT
  // ========================================================================
  async openBackupsFolder() {
    try {
      const pluginDir = this.getPluginDirectory();
      const backupDir = path3.join(pluginDir, "cache-backups");
      if (!fs3.existsSync(backupDir)) {
        fs3.mkdirSync(backupDir, { recursive: true });
        new import_obsidian2.Notice(`${this.manifest?.name || "Local Image Compress"}: ${t(this.app, "backups.cache.title")}`);
        return;
      }
      const backups = this.cache.getAvailableBackups();
      if (backups.length === 0) {
        new import_obsidian2.Notice(`${this.manifest?.name || "Local Image Compress"}: ${t(this.app, "backups.cache.none")}`);
        return;
      }
      const locale = getUserLang(this.app);
      const infoItems = await Promise.all(backups.map(async (backup) => {
        try {
          const backupPath = path3.join(backupDir, backup);
          const stats = await fs3.promises.stat(backupPath);
          const sizeKb = (stats.size / 1024).toFixed(1);
          const date = stats.mtime.toLocaleString(locale === 'en' ? undefined : locale);
          return `${backup} ${sizeKb} ${t(this.app, "units.kb")}, ${date}`;
        } catch (e) {
          return `${backup}`;
        }
      }));
      const backupInfo = infoItems.join("\n");
      this.showBackupModal(backupDir, backups, backupInfo);
    } catch (error) {
      new import_obsidian2.Notice(`${this.manifest?.name || "Local Image Compress"}: ${t(this.app, "backups.imagesFolder.openError")}`);
    }
  }
  showBackupModal(backupDir, backups, backupInfo) {
    const modal = new class extends import_obsidian2.Modal {
      onOpen() {
        const { contentEl } = this;
        contentEl.createEl("h2", { text: `${this.manifest?.name || "Local Image Compress"}: ${t(this.app, "backups.cache.title")}` });
        contentEl.createEl("p", { text: `${t(this.app, "backups.pathLabel")}: ${backupDir}` });
        contentEl.createEl("p", { text: `${t(this.app, "backups.foundLabel")}: ${backups.length}` });
        contentEl.createEl("h3", { text: t(this.app, "backups.cache.title") });
        const list = contentEl.createEl("div", { cls: "tiny-local-backup-list" });
        backupInfo.split("\n").forEach((line) => {
          list.createEl("div", { text: line });
        });
        const openButton = contentEl.createEl("button", {
          text: t(this.app, "backups.imagesFolder.openButton"),
          cls: "mod-cta"
        });
        openButton.addEventListener("click", () => {
          try {
            const { exec } = require("child_process");
            const platform = process.platform;
            const quotedPath = backupDir.replace(/"/g, '\\"');
            let cmd;
            if (platform === 'win32') {
              cmd = `explorer "${quotedPath}"`;
            } else if (platform === 'darwin') {
              cmd = `open "${quotedPath}"`;
            } else {
              cmd = `xdg-open "${quotedPath}"`;
            }
            exec(cmd, (error) => {
              if (error) {
                new import_obsidian2.Notice(`${this.manifest?.name || "Local Image Compress"}: ${t(this.app, "backups.imagesFolder.openError")}`);
              }
            });
          } catch (err) {
            new import_obsidian2.Notice(`${this.manifest?.name || "Local Image Compress"}: ${t(this.app, "backups.imagesFolder.openError")}`);
          }
        });
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    }(this.app);
    modal.open();
  }
  
  // ========================================================================
  // FILE SEARCH
  // ========================================================================
  
  async findOriginalFile(fileName) {
    // Search file across the entire vault via Obsidian API
    const allFiles = this.app.vault.getFiles();
    
    // Filter files by settings
    const targetFile = allFiles.find(file => {
      // Check file name
      if (file.name !== fileName) return false;
      
      // Ensure it is an image
      if (!this.isImageFile(file)) return false;
      
      // Ensure file is not inside the compressed folder
      if (isInsideOutputFolder(file.path, this.settings.outputFolder)) return false;
      
      // Check allowed root folders
      if (this.settings.allowedRoots && this.settings.allowedRoots.length > 0) {
        const isAllowed = this.settings.allowedRoots.some(root => 
          file.path.startsWith(root)
        );
        if (!isAllowed) return false;
      }
      
      return true;
    });
    
    if (targetFile) {
      return path3.join(this.app.vault.adapter.basePath, targetFile.path);
    }
    
    return null;
  }
  
  async getCompressedFilesCount() {
    try {
      const compressedFolderPath = path3.join(this.app.vault.adapter.basePath, this.settings.outputFolder);
      
      if (!fs3.existsSync(compressedFolderPath)) {
        return 0;
      }
      
      // Get all compressed files
      const allCompressedFiles = await this.getCompressedFilesAsync(compressedFolderPath);
      
      // Optimization: bail if none
      if (allCompressedFiles.length === 0) {
        return 0;
      }
      
      // Filter files that can be moved (original exists in allowed roots)
      let movableCount = 0;
      
      for (const compressedFile of allCompressedFiles) {
        const originalPath = await this.findOriginalFile(compressedFile.name);
        if (originalPath) {
          movableCount++;
        }
      }
      
      return movableCount;
    } catch (error) {
      console.error(getLogTag(this), "Compressed files count error:", error);
      return 0;
    }
  }
  
  // ========================================================================
  // MOVE COMPRESSED FILES
  // ========================================================================
  
  async moveCompressedToFiles() {
    await this.withPluginsDisabled(
      ["obsidian-paste-image-rename"],
      async () => {
        try {
          // Resolve path to compressed folder
          const compressedFolderPath = path3.join(this.app.vault.adapter.basePath, this.settings.outputFolder);
          
          // Ensure folder exists
          if (!fs3.existsSync(compressedFolderPath)) {
            new import_obsidian2.Notice(`${getPluginName(this)}: ${t(this.app, "move.noCompressedFolder")}`);
            return;
          }
          
          // Enumerate all files in compressed folder
          const allCompressedFiles = this.getCompressedFiles(compressedFolderPath);
          
          if (allCompressedFiles.length === 0) {
            new import_obsidian2.Notice(`${getPluginName(this)}: ${t(this.app, "move.noneToMove")}`);
            return;
          }
          
          // Keep only files that can be moved (have originals in allowed roots)
          const compressedFiles = [];
          for (const compressedFile of allCompressedFiles) {
            const originalPath = await this.findOriginalFile(compressedFile.name);
            if (originalPath) {
              compressedFiles.push(compressedFile);
            }
          }
          
          if (compressedFiles.length === 0) {
            new import_obsidian2.Notice(`${getPluginName(this)}: ${t(this.app, "move.noneWithOriginals")}`);
            return;
          }
          
          // Create backup of originals
          const backupCreated = await this.createBackupBeforeMove(compressedFiles);
          
          // Show progress bar
          const progressModal = this.showMoveProgressModal(compressedFiles.length);
          
          let successCount = 0;
          let errorCount = 0;
          
          // Move files
          for (let i = 0; i < compressedFiles.length; i++) {
            const compressedFile = compressedFiles[i];
            
            try {
              // Update progress
              progressModal.updateProgress(i + 1, compressedFiles.length, compressedFile.name);
              
              // Move one file
              await this.moveSingleFile(compressedFile);
              successCount++;
              
              // Small delay for smoother UI
              await new Promise(resolve => setTimeout(resolve, 50));
              
                    } catch (error) {
          console.error(getLogTag(this), `Move error for ${compressedFile.name}:`, error.message || error);
          errorCount++;
        }
          }
          
          // Close progress bar
          progressModal.close();
          
          // Show result
          this.showMoveResult(successCount, errorCount, backupCreated);
          
        } catch (error) {
          console.error(getLogTag(this), "Error while moving files:", error);
          new import_obsidian2.Notice(`${this.manifest?.name || "Local Image Compress"}: Error while moving files`);
        }
      }
    );
  }
  
  async getCompressedFilesAsync(compressedFolderPath) {
    const files = [];
    const walk = async (dirPath, relativePath = "") => {
      let items;
      try {
        items = await fs3.promises.readdir(dirPath, { withFileTypes: true });
      } catch (e) {
        console.error(getLogTag(this), 'Failed to read directory:', dirPath, e);
        return;
      }
      for (const entry of items) {
        const name = entry.name;
        const fullPath = path3.join(dirPath, name);
        const relativeItemPath = path3.join(relativePath, name);
        if (entry.isDirectory()) {
          await walk(fullPath, relativeItemPath);
        } else {
          if (this.isImageFile({ extension: path3.extname(name).slice(1).toLowerCase() })) {
            try {
              const stats = await fs3.promises.stat(fullPath);
              files.push({ compressedPath: fullPath, relativePath: relativeItemPath, name, size: stats.size });
            } catch (e) {
              console.error(getLogTag(this), 'Failed to stat path:', fullPath, e);
            }
          }
        }
        // Micro-pause to keep UI responsive in huge trees
        if (files.length % 200 === 0) {
          await new Promise((r) => setTimeout(r, 0));
        }
      }
    };
    await walk(compressedFolderPath);
    return files;
  }
  
  async createBackupBeforeMove(compressedFiles) {
    try {
      const pluginDir = this.getPluginDirectory();
      const backupDir = path3.join(pluginDir, "original-files-backups");
      if (!fs3.existsSync(backupDir)) {
        fs3.mkdirSync(backupDir, { recursive: true });
      }
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
      const backupPath = path3.join(backupDir, `backup-${timestamp}`);
      fs3.mkdirSync(backupPath, { recursive: true });
      
      let backupCount = 0;
      
      for (const compressedFile of compressedFiles) {
        try {
          // Find original file
          const originalPath = await this.findOriginalFile(compressedFile.name);
          
          // Backup original file (if found)
          if (originalPath && fs3.existsSync(originalPath)) {
            // Compute path relative to vault root for backup
            const relativeToVault = path3.relative(this.app.vault.adapter.basePath, originalPath);
            const backupFilePath = path3.join(backupPath, "originals", relativeToVault);
            const backupFileDir = path3.dirname(backupFilePath);
            
            // Create directories if needed
            if (!fs3.existsSync(backupFileDir)) {
              fs3.mkdirSync(backupFileDir, { recursive: true });
            }
            
            // Copy original file to backup
            fs3.copyFileSync(originalPath, backupFilePath);
            backupCount++;
          }
          
          // Backup compressed file
          const compressedRelativePath = path3.relative(this.app.vault.adapter.basePath, compressedFile.compressedPath);
          const compressedBackupPath = path3.join(backupPath, "compressed", compressedRelativePath);
          const compressedBackupDir = path3.dirname(compressedBackupPath);
          
          // Create directories if needed
          if (!fs3.existsSync(compressedBackupDir)) {
            fs3.mkdirSync(compressedBackupDir, { recursive: true });
          }
          
          // Copy compressed file to backup
          fs3.copyFileSync(compressedFile.compressedPath, compressedBackupPath);
          backupCount++;
          
        } catch (error) {
          console.error(getLogTag(this), `Backup creation error for ${compressedFile.name}:`, error);
        }
      }
      
      if (backupCount > 0) {
        new import_obsidian2.Notice(`${this.manifest?.name || "Local Image Compress"}: Created backup of ${backupCount} original files`);
        // Apply automatic cleanup of old backups by retention
        await this.applyBackupsRetention(backupDir);
        return true;
      }
      
      return false;
    } catch (error) {
      console.error(getLogTag(this), "Backup creation error:", error);
      return false;
    }
  }

  async applyBackupsRetention(backupDir) {
    try {
      const days = this.settings.autoBackupsRetentionDays;
      if (typeof days !== 'number' || days <= 0) return;
      if (!fs3.existsSync(backupDir)) return;

      const now = Date.now();
      const ttlMs = days * 24 * 60 * 60 * 1000;

      const entries = fs3.readdirSync(backupDir)
        .map(name => ({ name, path: path3.join(backupDir, name) }))
        .filter(e => fs3.statSync(e.path).isDirectory())
        .map(e => ({ ...e, ctime: fs3.statSync(e.path).ctimeMs }))
        .filter(e => (now - e.ctime) > ttlMs);

      for (const entry of entries) {
        try {
          this.deleteDirectoryRecursive(entry.path);
        } catch (err) {
          console.error(getLogTag(this), 'Expired backup removal error:', entry.path, err);
        }
      }
    } catch (err) {
      console.error(getLogTag(this), 'Backups retention apply error:', err);
    }
  }
  
  async moveSingleFile(compressedFile) {
    try {
      // Search for original file across the vault
      const originalPath = await this.findOriginalFile(compressedFile.name);
      
      if (!originalPath) {
        throw new Error(`Original file not found: ${compressedFile.name}`);
      }
      
      // Validate compressed file size against original
      const originalStats = fs3.statSync(originalPath);
      
      if (compressedFile.size >= originalStats.size) {
        throw new Error(`Compressed file is larger or equal to original: ${compressedFile.name}`);
      }
      
      // Replace original with compressed file
      fs3.copyFileSync(compressedFile.compressedPath, originalPath);
      
      // Remove compressed file
      fs3.unlinkSync(compressedFile.compressedPath);
      
    } catch (error) {
      console.error(getLogTag(this), `moveSingleFile error for ${compressedFile.name}:`, error.message || error);
      throw error;
    }
  }
  
  showMoveProgressModal(totalFiles) {
    const modal = new class extends import_obsidian2.Modal {
      constructor(app, totalFiles) {
        super(app);
        this.totalFiles = totalFiles;
        this.currentFile = 0;
      }
      
      onOpen() {
        const { contentEl } = this;
        contentEl.addClass("tiny-local-move-progress-modal");
        
        contentEl.createEl("h2", { text: `${this.manifest?.name || "Local Image Compress"}: ${t(this.app, "move.title")}` });
        
        this.progressText = contentEl.createEl("p", { 
          text: `${t(this.app, "progress.processing")}: 0 / ${this.totalFiles}` 
        });
        
        this.currentFileText = contentEl.createEl("p", { 
          text: t(this.app, "common.refresh") 
        });
        
        this.progressBar = contentEl.createEl("div", { 
          cls: "tiny-local-progress-bar" 
        });
        
        this.progressFill = contentEl.createEl("div", { 
          cls: "tiny-local-progress-fill" 
        });
        
        this.progressBar.appendChild(this.progressFill);
      }
      
      updateProgress(current, total, fileName) {
        this.currentFile = current;
        const percentage = (current / total) * 100;
        
        this.progressText.setText(`${t(this.app, "common.refresh")}: ${current} / ${total}`);
        this.currentFileText.setText(`${t(this.app, "progress.processing")}: ${fileName}`);
        this.progressFill.style.width = `${percentage}%`;
      }
      
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    }(this.app, totalFiles);
    
    modal.open();
    return modal;
  }
  
  showMoveResult(successCount, errorCount, backupCreated) {
    const modal = new class extends import_obsidian2.Modal {
      constructor(app, successCount, errorCount, backupCreated) {
        super(app);
        this.successCount = successCount;
        this.errorCount = errorCount;
        this.backupCreated = backupCreated;
      }
      
      onOpen() {
        const { contentEl } = this;
        contentEl.addClass("tiny-local-move-result-modal");
        
        contentEl.createEl("h2", { text: `${this.manifest?.name || "Local Image Compress"}: ${t(this.app, "move.title")}` });
        
        if (this.successCount > 0) {
          contentEl.createEl("p", { 
            text: `✅ ${t(this.app, "move.button")}: ${this.successCount}`,
            cls: "tiny-local-success"
          });
        }
        
        if (this.errorCount > 0) {
          contentEl.createEl("p", { 
            text: `❌ ${t(this.app, "progress.error")}: ${this.errorCount}`,
            cls: "tiny-local-error"
          });
        }
        
        if (this.backupCreated) {
          contentEl.createEl("p", { 
            text: "💾 Создан бэкап оригинальных и сжатых файлов",
            cls: "tiny-local-info"
          });
        }
        
        const closeButton = contentEl.createEl("button", {
          text: "Close",
          cls: "mod-cta"
        });
        
        closeButton.addEventListener("click", () => {
          this.close();
        });
      }
      
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    }(this.app, successCount, errorCount, backupCreated);
    
    modal.open();
  }
  
  async clearOriginalFilesBackups() {
    try {
      const pluginDir = this.getPluginDirectory();
      const backupDir = path3.join(pluginDir, "original-files-backups");
      
      const exists = await fs3.promises.access(backupDir).then(() => true).catch(() => false);
      if (!exists) {
        new import_obsidian2.Notice(`${this.manifest?.name || "Local Image Compress"}: Backups folder not found`);
        return;
      }
      
      const backups = await fs3.promises.readdir(backupDir);
      
      if (backups.length === 0) {
        new import_obsidian2.Notice(`${this.manifest?.name || "Local Image Compress"}: No backups to delete`);
        return;
      }
      
      let deletedCount = 0;
      for (const backup of backups) {
        const backupPath = path3.join(backupDir, backup);
        const stats = await fs3.promises.lstat(backupPath);
        
        if (stats.isDirectory()) {
          // Recursively delete folder
          await this.deleteDirectoryRecursiveAsync(backupPath);
          deletedCount++;
        }
      }
      
      new import_obsidian2.Notice(`${this.manifest?.name || "Local Image Compress"}: Deleted ${deletedCount} original file backups`);
      
    } catch (error) {
      console.error(getLogTag(this), "Error while clearing backups:", error);
      new import_obsidian2.Notice(`${this.manifest?.name || "Local Image Compress"}: Error while clearing backups`);
    }
  }
  
  async deleteDirectoryRecursiveAsync(dirPath) {
    try {
      const entries = await fs3.promises.readdir(dirPath);
      for (const entry of entries) {
        const curPath = path3.join(dirPath, entry);
        const stats = await fs3.promises.lstat(curPath);
        if (stats.isDirectory()) {
          await this.deleteDirectoryRecursiveAsync(curPath);
        } else {
          try { await fs3.promises.unlink(curPath); } catch (e) { console.warn('Failed to delete file:', curPath, e); }
        }
      }
      try { await fs3.promises.rmdir(dirPath); } catch (e) { console.warn('Failed to remove directory:', dirPath, e); }
    } catch (e) {
      console.warn('Failed to remove directory tree:', dirPath, e);
    }
  }
  
  // ========================================================================
  // THEME ADAPTATION
  // ========================================================================
  
  setupThemeAdaptation() {
    // Determine current theme on load
    this.updateThemeStyles();
    
    // Listen to theme changes
    this.registerEvent(
      this.app.workspace.on('layout-change', () => {
        this.updateThemeStyles();
      })
    );
    
    // Listen to system color-scheme changes
    if (window.matchMedia) {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
      mediaQuery.addEventListener('change', () => {
        this.updateThemeStyles();
      });
    }
  }
  
  getCurrentTheme() {
    const body = document.body;
    if (body.classList.contains('theme-light')) return 'light';
    if (body.classList.contains('theme-dark')) return 'dark';
    return 'system';
  }
  
  updateThemeStyles() {
    const theme = this.getCurrentTheme();
    const root = document.documentElement;
    
    // Set CSS variables depending on theme
    if (theme === 'light') {
      root.style.setProperty('--tiny-local-accent', '#3B82F6');
      root.style.setProperty('--tiny-local-accent-hover', '#2563EB');
    } else {
      root.style.setProperty('--tiny-local-accent', '#60A5FA');
      root.style.setProperty('--tiny-local-accent-hover', '#3B82F6');
    }
    

  }
  
  // Force style update method
  forceThemeUpdate() {
    this.updateThemeStyles();
  }
};
