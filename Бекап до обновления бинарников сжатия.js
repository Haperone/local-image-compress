/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TinyLocal
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");
var path3 = __toESM(require("path"));
var fs3 = __toESM(require("fs"));

// settings.ts
var DEFAULT_SETTINGS = {
  pngQuality: {
    min: 65,
    max: 80
  },
  jpegQuality: 85,
  allowedRoots: [],
  outputFolder: "Compressed",
  autoCompressNewFiles: false,
  autoBackgroundCompression: true,
  autoBackgroundThreshold: 50
};

// settings-tab.ts
var import_obsidian = require("obsidian");
var SettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "TinyPNG (Local) - \u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438" });
    
    // Добавляем индикатор экономии места
    await this.renderSavingsIndicator(containerEl);
    
    // ========================================================================
    // КАЧЕСТВО СЖАТИЯ
    // ========================================================================
    containerEl.createEl("h3", { text: "\u041A\u0430\u0447\u0435\u0441\u0442\u0432\u043E \u0441\u0436\u0430\u0442\u0438\u044F" });
    new import_obsidian.Setting(containerEl).setName("\u041A\u0430\u0447\u0435\u0441\u0442\u0432\u043E PNG (\u043C\u0438\u043D-\u043C\u0430\u043A\u0441)").setDesc("\u0414\u0438\u0430\u043F\u0430\u0437\u043E\u043D \u043A\u0430\u0447\u0435\u0441\u0442\u0432\u0430 \u0434\u043B\u044F \u0441\u0436\u0430\u0442\u0438\u044F PNG \u0444\u0430\u0439\u043B\u043E\u0432 (65-80 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E)").addText((text) => text.setPlaceholder("65-80").setValue(`${this.plugin.settings.pngQuality.min}-${this.plugin.settings.pngQuality.max}`).onChange(async (value) => {
      const parts = value.split("-");
      if (parts.length === 2) {
        const min = parseInt(parts[0]);
        const max = parseInt(parts[1]);
        if (!isNaN(min) && !isNaN(max) && min >= 0 && max <= 100 && min <= max) {
          this.plugin.settings.pngQuality.min = min;
          this.plugin.settings.pngQuality.max = max;
          await this.plugin.saveSettings();
        }
      }
    }));
    new import_obsidian.Setting(containerEl).setName("\u041A\u0430\u0447\u0435\u0441\u0442\u0432\u043E JPEG").setDesc("\u041A\u0430\u0447\u0435\u0441\u0442\u0432\u043E \u0441\u0436\u0430\u0442\u0438\u044F JPEG \u0444\u0430\u0439\u043B\u043E\u0432 (1-95)").addSlider((slider) => slider.setLimits(1, 95, 1).setValue(this.plugin.settings.jpegQuality).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.jpegQuality = value;
      await this.plugin.saveSettings();
    }));
    
    // ========================================================================
    // НАСТРОЙКИ ПУТЕЙ
    // ========================================================================
    containerEl.createEl("h3", { text: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043F\u0443\u0442\u0435\u0439" });
    new import_obsidian.Setting(containerEl).setName("\u0420\u0430\u0437\u0440\u0435\u0448\u0435\u043D\u043D\u044B\u0435 \u043A\u043E\u0440\u043D\u0438").setDesc("\u0421\u043F\u0438\u0441\u043E\u043A \u043E\u0442\u043D\u043E\u0441\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0445 \u043F\u0443\u0442\u0435\u0439, \u0433\u0434\u0435 \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043D\u043E \u0441\u0436\u0430\u0442\u0438\u0435 (\u043F\u0443\u0441\u0442\u043E = \u0432\u0441\u0435 \u043F\u0443\u0442\u0438)").addTextArea((text) => text.setPlaceholder("images/\nattachments/\nphotos/").setValue(this.plugin.settings.allowedRoots.join("\n")).onChange(async (value) => {
      this.plugin.settings.allowedRoots = value.split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("\u0412\u044B\u0445\u043E\u0434\u043D\u0430\u044F \u043F\u0430\u043F\u043A\u0430").setDesc("\u0418\u043C\u044F \u043F\u0430\u043F\u043A\u0438 \u0434\u043B\u044F \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u044F \u0441\u0436\u0430\u0442\u044B\u0445 \u0444\u0430\u0439\u043B\u043E\u0432").addText((text) => text.setPlaceholder("Compressed").setValue(this.plugin.settings.outputFolder).onChange(async (value) => {
      this.plugin.settings.outputFolder = value.trim() || "Compressed";
      await this.plugin.saveSettings();
    }));
    
    // ========================================================================
    // АВТОМАТИЗАЦИЯ
    // ========================================================================
    containerEl.createEl("h3", { text: "\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0437\u0430\u0446\u0438\u044F" });
    new import_obsidian.Setting(containerEl).setName("\u0410\u0432\u0442\u043E\u0441\u0436\u0430\u0442\u0438\u0435 \u043D\u043E\u0432\u044B\u0445 \u0444\u0430\u0439\u043B\u043E\u0432").setDesc("\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u0441\u0436\u0438\u043C\u0430\u0442\u044C \u043D\u043E\u0432\u044B\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u043F\u0440\u0438 \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u0438\u0438 \u0432 vault").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoCompressNewFiles).onChange(async (value) => {
      this.plugin.settings.autoCompressNewFiles = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u043E\u0435 \u0444\u043E\u043D\u043E\u0432\u043E\u0435 \u0441\u0436\u0430\u0442\u0438\u0435").setDesc("\u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u0441\u0436\u0438\u043C\u0430\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0432 \u0444\u043E\u043D\u0435 \u043F\u0440\u0438 \u043F\u0440\u0435\u0432\u044B\u0448\u0435\u043D\u0438\u0438 \u043F\u043E\u0440\u043E\u0433\u0430 (\u0442\u043E\u043B\u044C\u043A\u043E \u043A\u043E\u0433\u0434\u0430 \u043D\u0435\u0430\u043A\u0442\u0438\u0432\u0435\u043D)").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoBackgroundCompression).onChange(async (value) => {
      this.plugin.settings.autoBackgroundCompression = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Порог для фонового сжатия").setDesc("Количество несжатых изображений, при котором запускается автоматическое фоновое сжатие").addSlider((slider) => slider.setLimits(10, 1000, 5).setValue(this.plugin.settings.autoBackgroundThreshold).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.autoBackgroundThreshold = value;
      this.plugin.AUTO_BACKGROUND_THRESHOLD = value;
      await this.plugin.saveSettings();
    }));
    // ========================================================================
    // СТАТИСТИКА И КЭШ
    // ========================================================================
    containerEl.createEl("h3", { text: "\u0421\u0442\u0430\u0442\u0438\u0441\u0442\u0438\u043A\u0430 \u0438 \u043A\u044D\u0448" });
    this.plugin.getUncompressedImagesCount().then((count) => {
      new import_obsidian.Setting(containerEl).setName("\u041D\u0435\u0441\u0436\u0430\u0442\u044B\u0445 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439").setDesc(`${count} \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439 \u0433\u043E\u0442\u043E\u0432\u044B \u043A \u0441\u0436\u0430\u0442\u0438\u044E`).addButton((button) => button.setButtonText("\u041E\u0431\u043D\u043E\u0432\u0438\u0442\u044C").onClick(async () => {
        await this.plugin.forceRefreshCache();
        this.display();
      }));
    });
    const cacheStats = this.plugin.cache.getCacheStats();
    new import_obsidian.Setting(containerEl).setName("\u0417\u0430\u043F\u0438\u0441\u0435\u0439 \u0432 \u043A\u044D\u0448\u0435").setDesc(`${cacheStats.total} \u0437\u0430\u043F\u0438\u0441\u0435\u0439, \u0440\u0430\u0437\u043C\u0435\u0440: ${Math.round(cacheStats.size / 1024)} \u041A\u0411`).addButton((button) => button.setButtonText("\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C \u043A\u044D\u0448").onClick(async () => {
      await this.plugin.cache.clearCache();
      await this.plugin.updateStatusBar();
      this.display();
    })).addButton((button) => button.setButtonText("\u041E\u0431\u043D\u043E\u0432\u0438\u0442\u044C \u043A\u044D\u0448").onClick(async () => {
      await this.plugin.forceRefreshCache();
      new import_obsidian.Notice("TinyLocal: \u041A\u044D\u0448 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D");
      this.display();
    }));
    const ghostCount = await this.plugin.getGhostEntriesCount();
    new import_obsidian.Setting(containerEl).setName("\u041F\u0440\u0438\u0437\u0440\u0430\u0447\u043D\u044B\u0435 \u0437\u0430\u043F\u0438\u0441\u0438").setDesc(`${ghostCount} \u0437\u0430\u043F\u0438\u0441\u0435\u0439 \u0432 \u043A\u044D\u0448\u0435 \u0441\u0441\u044B\u043B\u0430\u044E\u0442\u0441\u044F \u043D\u0430 \u0443\u0434\u0430\u043B\u0435\u043D\u043D\u044B\u0435 \u0444\u0430\u0439\u043B\u044B`).addButton((button) => button.setButtonText("\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C \u043F\u0440\u0438\u0437\u0440\u0430\u043A\u0438").setWarning().onClick(async () => {
      const removedCount = await this.plugin.cleanupGhostEntries();
      new import_obsidian.Notice(`TinyLocal: \u0423\u0434\u0430\u043B\u0435\u043D\u043E ${removedCount} \u043F\u0440\u0438\u0437\u0440\u0430\u0447\u043D\u044B\u0445 \u0437\u0430\u043F\u0438\u0441\u0435\u0439 \u0438\u0437 \u043A\u044D\u0448\u0430`);
      this.display();
    }));
    // ========================================================================
    // СИСТЕМА
    // ========================================================================
    containerEl.createEl("h3", { text: "\u0421\u0438\u0441\u0442\u0435\u043C\u0430" });
    const compressor = this.plugin.compressor;
    const binaries = compressor.checkBinaries();
    new import_obsidian.Setting(containerEl).setName("pngquant").setDesc(binaries.pngquant ? "\u2713 \u0414\u043E\u0441\u0442\u0443\u043F\u0435\u043D" : "\u2717 \u041D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D").setDisabled(true);
    new import_obsidian.Setting(containerEl).setName("mozjpeg").setDesc(binaries.mozjpeg ? "\u2713 \u0414\u043E\u0441\u0442\u0443\u043F\u0435\u043D" : "\u2717 \u041D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D").setDisabled(true);
    // ========================================================================
    // БЭКАПЫ
    // ========================================================================
    containerEl.createEl("h3", { text: "\u0411\u0435\u043A\u0430\u043F\u044B \u043A\u0435\u0448\u0430" });
    const backups = this.plugin.cache.getAvailableBackups();
    if (backups.length === 0) {
      new import_obsidian.Setting(containerEl).setName("\u0411\u0435\u043A\u0430\u043F\u044B \u043A\u0435\u0448\u0430").setDesc("\u041D\u0435\u0442 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B\u0445 \u0431\u0435\u043A\u0430\u043F\u043E\u0432 \u043A\u0435\u0448\u0430").setDisabled(true);
    } else {
      new import_obsidian.Setting(containerEl).setName("\u0412\u043E\u0441\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u043A\u0435\u0448 \u0438\u0437 \u0431\u0435\u043A\u0430\u043F\u0430").setDesc(`\u0414\u043E\u0441\u0442\u0443\u043F\u043D\u043E ${backups.length} \u0431\u0435\u043A\u0430\u043F\u043E\u0432`).addDropdown((dropdown) => {
        dropdown.addOption("", "-- \u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0431\u0435\u043A\u0430\u043F --");
        backups.forEach((backup) => {
          const date = backup.replace("tinyLocal-cache-backup-", "").replace(".json", "").replace(/-/g, ":").replace(/T/, " ");
          dropdown.addOption(backup, date);
        });
        dropdown.onChange(async (value) => {
          if (value) {
            const success = await this.plugin.cache.restoreFromBackup(value);
            if (success) {
              await this.plugin.updateStatusBar();
              new import_obsidian.Notice(`TinyLocal: \u041A\u0435\u0448 \u0432\u043E\u0441\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D \u0438\u0437 \u0431\u0435\u043A\u0430\u043F\u0430: ${value}`);
              this.display();
            } else {
              new import_obsidian.Notice("TinyLocal: \u041E\u0448\u0438\u0431\u043A\u0430 \u0432\u043E\u0441\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F \u043A\u0435\u0448\u0430");
            }
          }
        });
      });
    }
    containerEl.createEl("h3", { text: "\u0423\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u0435 \u0431\u0435\u043A\u0430\u043F\u0430\u043C\u0438 \u043A\u044D\u0448\u0430" });
    new import_obsidian.Setting(containerEl).setName("\u041F\u0430\u043F\u043A\u0430 \u0441 \u0431\u0435\u043A\u0430\u043F\u0430\u043C\u0438").setDesc("\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u043F\u0430\u043F\u043A\u0443 \u0441 \u0431\u0435\u043A\u0430\u043F\u0430\u043C\u0438 \u043A\u044D\u0448\u0430 \u0434\u043B\u044F \u043F\u0440\u043E\u0441\u043C\u043E\u0442\u0440\u0430 \u0438 \u0432\u043E\u0441\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F").addButton((button) => button.setButtonText("\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u043F\u0430\u043F\u043A\u0443 \u0441 \u0431\u0435\u043A\u0430\u043F\u0430\u043C\u0438").onClick(async () => {
      await this.plugin.openBackupsFolder();
    }));
    
    // ========================================================================
    // СИСТЕМА
    // ========================================================================
    containerEl.createEl("h3", { text: "\u0421\u0438\u0441\u0442\u0435\u043C\u0430" });
    const compressor = this.plugin.compressor;
    const binaries = compressor.checkBinaries();
    new import_obsidian.Setting(containerEl).setName("pngquant").setDesc(binaries.pngquant ? "\u2713 \u0414\u043E\u0441\u0442\u0443\u043F\u0435\u043D" : "\u2717 \u041D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D").setDisabled(true);
    new import_obsidian.Setting(containerEl).setName("mozjpeg").setDesc(binaries.mozjpeg ? "\u2713 \u0414\u043E\u0441\u0442\u0443\u043F\u0435\u043D" : "\u2717 \u041D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D").setDisabled(true);
    
    // ========================================================================
    // ИНСТРУКЦИИ
    // ========================================================================
    containerEl.createEl("h3", { text: "\u0418\u043D\u0441\u0442\u0440\u0443\u043A\u0446\u0438\u0438" });
    const instructions = containerEl.createEl("div", { cls: "setting-item-description" });
    instructions.innerHTML = `
			<p><strong>\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0435:</strong></p>
			<ul>
				<li>\u041F\u0440\u0430\u0432\u044B\u0439 \u043A\u043B\u0438\u043A \u043D\u0430 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0438 \u2192 "\u0421\u0436\u0430\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435"</li>
				<li>Command Palette \u2192 "\u0421\u0436\u0430\u0442\u044C \u0432\u0441\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0432 \u0437\u0430\u043C\u0435\u0442\u043A\u0435"</li>
				<li>Command Palette \u2192 "\u0421\u0436\u0430\u0442\u044C \u0432\u0441\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0432 \u043F\u0430\u043F\u043A\u0435"</li>
				<li>Command Palette \u2192 "\u0421\u0436\u0430\u0442\u044C \u0432\u0441\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0432 vault"</li>
			</ul>
			<p><strong>\u041F\u0440\u0438\u043C\u0435\u0447\u0430\u043D\u0438\u044F:</strong></p>
			<ul>
				<li>\u0421\u0436\u0430\u0442\u044B\u0435 \u0444\u0430\u0439\u043B\u044B \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u044E\u0442\u0441\u044F \u0432 \u043F\u0430\u043F\u043A\u0443 "${this.plugin.settings.outputFolder}"</li>
				<li>\u041E\u0440\u0438\u0433\u0438\u043D\u0430\u043B\u044C\u043D\u044B\u0435 \u0444\u0430\u0439\u043B\u044B \u043D\u0435 \u0438\u0437\u043C\u0435\u043D\u044F\u044E\u0442\u0441\u044F</li>
				<li>\u041F\u043E\u0432\u0442\u043E\u0440\u043D\u043E\u0435 \u0441\u0436\u0430\u0442\u0438\u0435 \u043F\u0440\u043E\u043F\u0443\u0441\u043A\u0430\u0435\u0442\u0441\u044F \u0431\u043B\u0430\u0433\u043E\u0434\u0430\u0440\u044F \u043A\u044D\u0448\u0443</li>
			</ul>
		`;
  }
  
  async renderSavingsIndicator(containerEl) {
    try {
      // Проверяем, нужно ли показывать индикатор
      if (!this.plugin.shouldShowSavingsIndicator()) {
        return;
      }
      
      // Дополнительная проверка на наличие валидных данных
      if (!(await this.plugin.hasValidSavingsData())) {
        return;
      }
      
      const savings = await this.plugin.calculateSpaceSavings();
      
      if (!this.plugin.validateSavingsData(savings)) {
        return; // Не показываем если нет валидных данных
      }
      
      // Создаем контейнер для индикатора
      const indicatorContainer = containerEl.createEl("div", {
        cls: "tiny-local-savings-indicator"
      });
      
      // Создаем текстовую информацию
      const textInfo = indicatorContainer.createEl("div", {
        cls: "tiny-local-savings-text"
      });
      
      const { originalFormatted, currentFormatted, savedFormatted, estimatedIndicator } = this.plugin.formatTooltipData(savings);
      
      textInfo.innerHTML = `
        <strong>Original:</strong> ${originalFormatted}${estimatedIndicator} → 
        <strong>Current:</strong> ${currentFormatted} → 
        <strong>Saved:</strong> ${savedFormatted} (${savings.savedPercentage}%)${estimatedIndicator}
      `;
      
      // Создаем полосу заполнения
      const barContainer = indicatorContainer.createEl("div", {
        cls: "tiny-local-savings-bar"
      });
      
      // Рассчитываем пропорции для полосы с защитой от деления на ноль
      const totalWidth = 100;
      const savedWidth = savings.originalSize > 0 ? Math.min(100, Math.max(0, (savings.savedSize / savings.originalSize) * totalWidth)) : 0;
      const currentWidth = Math.max(0, totalWidth - savedWidth);
      

      
      // Создаем блок сэкономленного места
      if (savedWidth > 0) {
        const savedBlock = barContainer.createEl("div", {
          cls: "tiny-local-savings-saved"
        });
        savedBlock.style.width = `${savedWidth}%`;
      }
      
      // Создаем блок текущего размера (всегда создаем, даже если 0%)
      const currentBlock = barContainer.createEl("div", {
        cls: "tiny-local-savings-current"
      });
      currentBlock.style.width = `${currentWidth}%`;
      
      // Fallback: если оба блока равны 0, создаем пустой блок для видимости
      if (savedWidth === 0 && currentWidth === 0) {
        const fallbackBlock = barContainer.createEl("div", {
          cls: "tiny-local-savings-current"
        });
        fallbackBlock.style.width = "100%";
      }
      
      // Добавляем tooltip
      this.createSavingsTooltip(indicatorContainer, savings);
      
    } catch (error) {
      console.error("[TinyLocal] Ошибка отрисовки индикатора экономии:", error);
    }
  }
  
  createSavingsTooltip(container, savings) {
    try {
      const { originalFormatted, currentFormatted, savedFormatted, estimatedIndicator, estimatedText } = this.plugin.formatTooltipData(savings);
      
      const tooltipContent = `
        <div class="tiny-local-savings-tooltip">
          <div class="tooltip-header">Space Savings Details</div>
          <div class="tooltip-item">
            <span class="tooltip-label">Original Size:</span>
            <span class="tooltip-value">${originalFormatted}${estimatedIndicator}</span>
          </div>
          <div class="tooltip-item">
            <span class="tooltip-label">Current Size:</span>
            <span class="tooltip-value">${currentFormatted}</span>
          </div>
          <div class="tooltip-item">
            <span class="tooltip-label">Space Saved:</span>
            <span class="tooltip-value">${savedFormatted} (${savings.savedPercentage}%)${estimatedIndicator}</span>
          </div>
          <div class="tooltip-item">
            <span class="tooltip-label">Files Processed:</span>
            <span class="tooltip-value">${savings.processedFiles} / ${savings.totalFiles}${estimatedText}</span>
          </div>
        </div>
      `;
      
      // Создаем кастомный tooltip
      let tooltip = null;
      let isMouseOver = false;
      
      const showTooltip = (e) => {
        if (tooltip || !isMouseOver) return;
        
        tooltip = document.createElement('div');
        tooltip.innerHTML = tooltipContent;
        tooltip.style.position = 'absolute';
        tooltip.style.zIndex = '1000';
        tooltip.style.pointerEvents = 'none';
        
        document.body.appendChild(tooltip);
        
        // Позиционируем tooltip с задержкой для корректного расчета размеров
        requestAnimationFrame(() => {
          if (!tooltip || !document.body.contains(tooltip)) return;
          
          const rect = container.getBoundingClientRect();
          const tooltipRect = tooltip.getBoundingClientRect();
          
          let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
          let top = rect.top - tooltipRect.height - 10;
          
          // Проверяем границы экрана
          const margin = 10;
          const maxLeft = window.innerWidth - tooltipRect.width - margin;
          const maxTop = window.innerHeight - tooltipRect.height - margin;
          
          left = Math.max(margin, Math.min(left, maxLeft));
          
          if (top < margin) {
            top = rect.bottom + margin;
          }
          top = Math.max(margin, Math.min(top, maxTop));
          
          tooltip.style.left = left + 'px';
          tooltip.style.top = top + 'px';
        });
      };
      
      const hideTooltip = () => {
        if (tooltip && document.body.contains(tooltip)) {
          document.body.removeChild(tooltip);
        }
        tooltip = null;
        isMouseOver = false;
      };
      
      container.addEventListener('mouseenter', (e) => {
        isMouseOver = true;
        setTimeout(() => showTooltip(e), 200); // Небольшая задержка для предотвращения мерцания
      });
      
      container.addEventListener('mouseleave', () => {
        isMouseOver = false;
        setTimeout(hideTooltip, 100);
      });
      
      container.style.cursor = "help";
    } catch (error) {
      console.error("[TinyLocal] Ошибка создания tooltip:", error);
    }
  }
};

// compressor.ts
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));
var os = __toESM(require("os"));
var import_child_process = require("child_process");
var Compressor = class {
  constructor(pluginDir) {
    this.pngquantPath = null;
    this.mozjpegPath = null;
    this.initializeBinaries(pluginDir);
  }
  initializeBinaries(pluginDir) {
    try {
      const baseDir = pluginDir || process.cwd();
      const platform = process.platform;
      const arch = process.arch;
      const normalizedDir = path.resolve(baseDir).replace(/\//g, "\\");
      if (platform === "win32") {
        this.pngquantPath = path.join(normalizedDir, "node_modules", "pngquant-bin", "vendor", "pngquant.exe");
        this.mozjpegPath = path.join(normalizedDir, "node_modules", "mozjpeg", "vendor", "cjpeg.exe");
      } else if (platform === "darwin") {
        this.pngquantPath = path.join(normalizedDir, "node_modules", "pngquant-bin", "vendor", "pngquant");
        this.mozjpegPath = path.join(normalizedDir, "node_modules", "mozjpeg", "vendor", "cjpeg");
      } else {
        this.pngquantPath = path.join(normalizedDir, "node_modules", "pngquant-bin", "vendor", "pngquant");
        this.mozjpegPath = path.join(normalizedDir, "node_modules", "mozjpeg", "vendor", "cjpeg");
      }
    } catch (error) {
    }
  }
  checkBinaries() {
    const hasPngquant = Boolean(this.pngquantPath && fs.existsSync(this.pngquantPath));
    const hasMozjpeg = Boolean(this.mozjpegPath && fs.existsSync(this.mozjpegPath));
    return { pngquant: hasPngquant, mozjpeg: hasMozjpeg };
  }
  async compress(file, settings) {
    try {
      const adapter = file.vault.adapter;
      const basePath = adapter.path?.absolute || adapter.basePath || process.cwd();
      const filePath = path.join(basePath, file.path);
      const fileExtension = path.extname(file.path).toLowerCase();
      try {
        const stats = fs.statSync(filePath);
        const fd = fs.openSync(filePath, "r");
        const buffer = Buffer.alloc(10);
        fs.readSync(fd, buffer, 0, 10, 0);
        fs.closeSync(fd);
        var originalSize = stats.size;
      } catch (error) {
        return {
          success: false,
          error: `\u041D\u0435\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C \u0434\u043E\u0441\u0442\u0443\u043F \u043A \u0444\u0430\u0439\u043B\u0443: ${error instanceof Error ? error.message : "\u043D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430"}`
        };
      }
      const tempDir = os.tmpdir();
      const tempFileName = `tinylocal_${Date.now()}${fileExtension}`;
      const tempFilePath = path.join(tempDir, tempFileName);
      try {
        fs.copyFileSync(filePath, tempFilePath);
        let result;
        if (fileExtension === ".png") {
          result = await this.compressPNG(tempFilePath, basePath, file.path, settings, originalSize);
        } else if ([".jpg", ".jpeg"].includes(fileExtension)) {
          result = await this.compressJPEG(tempFilePath, basePath, file.path, settings, originalSize);
        } else {
          result = {
            success: false,
            error: "\u041D\u0435\u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u043C\u044B\u0439 \u0444\u043E\u0440\u043C\u0430\u0442 \u0444\u0430\u0439\u043B\u0430"
          };
        }
        try {
          fs.unlinkSync(tempFilePath);
        } catch (cleanupError) {
        }
        return result;
      } catch (copyError) {
        if (fileExtension === ".png") {
          return await this.compressPNG(filePath, basePath, file.path, settings, originalSize);
        } else if ([".jpg", ".jpeg"].includes(fileExtension)) {
          return await this.compressJPEG(filePath, basePath, file.path, settings, originalSize);
        } else {
          return {
            success: false,
            error: "\u041D\u0435\u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u043C\u044B\u0439 \u0444\u043E\u0440\u043C\u0430\u0442 \u0444\u0430\u0439\u043B\u0430"
          };
        }
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430"
      };
    }
  }
  async compressPNG(filePath, basePath, relativePath, settings, originalSize) {
    if (!this.pngquantPath) {
      return {
        success: false,
        error: "pngquant \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D"
      };
    }
    const tempOutputPath = path.join(os.tmpdir(), `tinylocal_out_${Date.now()}.png`);
    const finalOutputPath = this.getOutputPath(basePath, relativePath, settings.outputFolder);
    await this.ensureOutputDirectory(finalOutputPath);
    const args = [
      "--quality",
      `${settings.pngQuality.min}-${settings.pngQuality.max}`,
      "--force",
      "--output",
      tempOutputPath,
      filePath
    ];
    return new Promise((resolve2) => {
      const process2 = (0, import_child_process.spawn)(this.pngquantPath, args);
      let stderr = "";
      process2.stderr?.on("data", (data) => {
        stderr += data.toString();
      });
      process2.on("close", (code) => {
        if (code === 0) {
          try {
            const compressedSize = fs.statSync(tempOutputPath).size;
            const savings = Math.round((originalSize - compressedSize) / originalSize * 100);
            fs.copyFileSync(tempOutputPath, finalOutputPath);
            try {
              fs.unlinkSync(tempOutputPath);
            } catch (cleanupError) {
            }
            resolve2({
              success: true,
              savings
            });
          } catch (error) {
            resolve2({
              success: false,
              error: `\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0441\u0436\u0430\u0442\u044B\u0439 \u0444\u0430\u0439\u043B: ${error instanceof Error ? error.message : "\u043D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430"}`
            });
          }
        } else {
          try {
            fs.unlinkSync(tempOutputPath);
          } catch (cleanupError) {
          }
          resolve2({
            success: false,
            error: `pngquant \u0437\u0430\u0432\u0435\u0440\u0448\u0438\u043B\u0441\u044F \u0441 \u043A\u043E\u0434\u043E\u043C ${code}: ${stderr}`
          });
        }
      });
      process2.on("error", (error) => {
        resolve2({
          success: false,
          error: `\u041E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u043F\u0443\u0441\u043A\u0430 pngquant: ${error.message}`
        });
      });
    });
  }
  async compressJPEG(filePath, basePath, relativePath, settings, originalSize) {
    if (!this.mozjpegPath) {
      return {
        success: false,
        error: "mozjpeg \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D"
      };
    }
    const tempOutputPath = path.join(os.tmpdir(), `tinylocal_out_${Date.now()}.jpg`);
    const finalOutputPath = this.getOutputPath(basePath, relativePath, settings.outputFolder);
    await this.ensureOutputDirectory(finalOutputPath);
    const args = [
      "-quality",
      settings.jpegQuality.toString(),
      "-optimize",
      "-outfile",
      tempOutputPath,
      filePath
    ];
    return new Promise((resolve2) => {
      const process2 = (0, import_child_process.spawn)(this.mozjpegPath, args);
      let stderr = "";
      process2.stderr?.on("data", (data) => {
        stderr += data.toString();
      });
      process2.on("close", (code) => {
        if (code === 0) {
          try {
            const compressedSize = fs.statSync(tempOutputPath).size;
            const savings = Math.round((originalSize - compressedSize) / originalSize * 100);
            fs.copyFileSync(tempOutputPath, finalOutputPath);
            try {
              fs.unlinkSync(tempOutputPath);
            } catch (cleanupError) {
            }
            resolve2({
              success: true,
              savings
            });
          } catch (error) {
            resolve2({
              success: false,
              error: `\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0441\u0436\u0430\u0442\u044B\u0439 JPEG \u0444\u0430\u0439\u043B: ${error instanceof Error ? error.message : "\u043D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430"}`
            });
          }
        } else {
          try {
            fs.unlinkSync(tempOutputPath);
          } catch (cleanupError) {
          }
          resolve2({
            success: false,
            error: `mozjpeg \u0437\u0430\u0432\u0435\u0440\u0448\u0438\u043B\u0441\u044F \u0441 \u043A\u043E\u0434\u043E\u043C ${code}: ${stderr}`
          });
        }
      });
      process2.on("error", (error) => {
        resolve2({
          success: false,
          error: `\u041E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u043F\u0443\u0441\u043A\u0430 mozjpeg: ${error.message}`
        });
      });
    });
  }
  getOutputPath(basePath, relativePath, outputFolder) {
    const filename = path.basename(relativePath);
    const outputDir = path.join(basePath, outputFolder);
    const outputPath = path.join(outputDir, filename);
    return outputPath;
  }
  async ensureOutputDirectory(outputPath) {
    const outputDir = path.dirname(outputPath);
    if (!fs.existsSync(outputDir)) {
      await fs.promises.mkdir(outputDir, { recursive: true });
    }
  }
};

// cache.ts
var fs2 = __toESM(require("fs"));
var path2 = __toESM(require("path"));
var crypto = __toESM(require("crypto"));
var Cache = class {
  constructor(app) {
    this.CACHE_VERSION = "1.0.0";
    this.app = app;
    const manifestDir = app.manifest?.dir;
    const configDir = app.vault.configDir;
    const adapter = app.vault.adapter;
    const basePath = adapter.path?.absolute || adapter.basePath || process.cwd();
    let cacheDir;
    if (manifestDir) {
      cacheDir = manifestDir.startsWith("/") || manifestDir.includes(":") ? manifestDir : `${basePath}/${manifestDir}`.replace(/\\/g, "/");
    } else {
      cacheDir = `${basePath}/${configDir}/plugins/tiny-local`.replace(/\\/g, "/");
    }
    this.cacheFile = path2.join(cacheDir, "tinyLocal-cache.json");
    this.cacheData = {
      entries: {},
      version: this.CACHE_VERSION
    };
    this.loadCacheSync();
  }
  loadCacheSync() {
    try {
      const cacheDir = path2.dirname(this.cacheFile);
      if (!fs2.existsSync(cacheDir)) {
        fs2.mkdirSync(cacheDir, { recursive: true });
      }
      if (!fs2.existsSync(this.cacheFile)) {
        const initialCache = {
          entries: {},
          version: this.CACHE_VERSION
        };
        fs2.writeFileSync(this.cacheFile, JSON.stringify(initialCache, null, 2));
      }
      if (fs2.existsSync(this.cacheFile)) {
        const data = fs2.readFileSync(this.cacheFile, "utf8");
        const parsed = JSON.parse(data);
        if (parsed.version === this.CACHE_VERSION) {
          this.cacheData = parsed;
        } else {
          this.cacheData = {
            entries: {},
            version: this.CACHE_VERSION
          };
        }
      }
    } catch (error) {
      this.cacheData = {
        entries: {},
        version: this.CACHE_VERSION
      };
    }
  }
  async saveCache() {
    try {
      const cacheDir = path2.dirname(this.cacheFile);
      if (!fs2.existsSync(cacheDir)) {
        fs2.mkdirSync(cacheDir, { recursive: true });
      }
      await fs2.promises.writeFile(this.cacheFile, JSON.stringify(this.cacheData, null, 2));
    } catch (error) {
    }
  }
  async getCacheKey(file) {
    try {
      const buffer = await this.app.vault.readBinary(file);
      const uint8Buffer = new Uint8Array(buffer);
      const md5 = crypto.createHash("md5").update(uint8Buffer).digest("hex");
      const mtime = file.stat.mtime;
      return `${file.path}:${md5}:${mtime}`;
    } catch (error) {
      return `${file.path}:${Date.now()}`;
    }
  }
  async isCached(cacheKey) {
    const entry = this.cacheData.entries[cacheKey];
    if (!entry) {
      return false;
    }
    return true;
  }
  // Улучшенный метод для проверки кэша только по пути файла
  async isFileAlreadyCompressed(filePath) {
    for (const [cacheKey, entry] of Object.entries(this.cacheData.entries)) {
      const keyPath = cacheKey.split(":")[0];
      if (keyPath === filePath) {
        return true;
      }
    }
    return false;
  }
  // Новый метод для принудительного обновления кэша (без проверки времени)
  async forceRefreshCache() {
    this.loadCacheSync();
  }
  async addToCache(cacheKey, originalSize = null) {
    try {
      this.cacheData.entries[cacheKey] = {
        md5: cacheKey.split(":")[1] || "",
        mtime: parseInt(cacheKey.split(":")[2]) || Date.now(),
        timestamp: Date.now(),
        originalSize: originalSize // Сохраняем оригинальный размер
      };
      await this.saveCache();
    } catch (error) {
    }
  }
  async addSkippedEntry(filePath, reason) {
    try {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file)
        return;
      const buffer = await this.app.vault.readBinary(file);
      const uint8Buffer = new Uint8Array(buffer);
      const md5 = crypto.createHash("md5").update(uint8Buffer).digest("hex");
      const entry = {
        md5,
        mtime: file.stat.mtime,
        timestamp: Date.now(),
        skipped: true,
        reason,
        originalSize: file.stat.size // Сохраняем размер для пропущенных файлов тоже
      };
      this.cacheData.entries[filePath] = entry;
      await this.saveCache();
    } catch (error) {
    }
  }
  async clearCache() {
    this.cacheData.entries = {};
    await this.saveCache();
  }
  getCacheStats() {
    const total = Object.keys(this.cacheData.entries).length;
    const size = JSON.stringify(this.cacheData).length;
    return { total, size };
  }
  // Система бекапов кеша
  createBackup() {
    try {
      if (!fs2.existsSync(this.cacheFile)) {
        return;
      }
      const cacheDir = path2.dirname(this.cacheFile);
      const backupDir = path2.join(cacheDir, "cache-backups");
      if (!fs2.existsSync(backupDir)) {
        fs2.mkdirSync(backupDir, { recursive: true });
      }
      const now = /* @__PURE__ */ new Date();
      const timestamp = now.toISOString().replace(/[:.]/g, "-").slice(0, 19);
      const randomSuffix = Math.floor(Math.random() * 1e3).toString().padStart(3, "0");
      const backupFile = path2.join(backupDir, `tinyLocal-cache-backup-${timestamp}-${randomSuffix}.json`);
      fs2.copyFileSync(this.cacheFile, backupFile);
      this.cleanupOldBackups(backupDir);
    } catch (error) {
    }
  }
  cleanupOldBackups(backupDir) {
    try {
      const files = fs2.readdirSync(backupDir).filter((file) => file.startsWith("tinyLocal-cache-backup-") && file.endsWith(".json")).map((file) => ({
        name: file,
        path: path2.join(backupDir, file),
        stat: fs2.statSync(path2.join(backupDir, file))
      })).sort((a, b) => b.stat.mtime.getTime() - a.stat.mtime.getTime());
      const filesToDelete = files.slice(10);
      for (const file of filesToDelete) {
        fs2.unlinkSync(file.path);
      }
    } catch (error) {
    }
  }
  // Улучшенный метод восстановления из бекапа
  async restoreFromBackup(backupFileName) {
    try {
      const backupDir = path2.join(path2.dirname(this.cacheFile), "cache-backups");
      let backupFile;
      if (backupFileName) {
        backupFile = path2.join(backupDir, backupFileName);
      } else {
        const files = fs2.readdirSync(backupDir).filter((file) => file.startsWith("tinyLocal-cache-backup-") && file.endsWith(".json")).map((file) => ({
          name: file,
          path: path2.join(backupDir, file),
          stat: fs2.statSync(path2.join(backupDir, file))
        })).sort((a, b) => b.stat.mtime.getTime() - a.stat.mtime.getTime());
        if (files.length === 0) {
          return false;
        }
        backupFile = files[0].path;
      }
      if (!fs2.existsSync(backupFile)) {
        return false;
      }
      this.createBackup();
      fs2.copyFileSync(backupFile, this.cacheFile);
      this.loadCacheSync();
      const now = Date.now();
      for (const [key, entry] of Object.entries(this.cacheData.entries)) {
        entry.timestamp = now;
      }
      await this.saveCache();
      return true;
    } catch (error) {
      console.error("[TinyLocal] \u041E\u0448\u0438\u0431\u043A\u0430 \u0432\u043E\u0441\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F \u0438\u0437 \u0431\u0435\u043A\u0430\u043F\u0430:", error);
      return false;
    }
  }
  getCacheFile() {
    return this.cacheFile;
  }
  getAvailableBackups() {
    try {
      const backupDir = path2.join(path2.dirname(this.cacheFile), "cache-backups");
      if (!fs2.existsSync(backupDir)) {
        return [];
      }
      const backups = fs2.readdirSync(backupDir).filter((file) => file.startsWith("tinyLocal-cache-backup-") && file.endsWith(".json")).sort().reverse();
      return backups;
    } catch (error) {
      return [];
    }
  }
  // Подсчет "призрачных" записей (файлы, которых больше нет)
  async getGhostEntriesCount() {
    let ghostCount = 0;
    for (const [cacheKey, entry] of Object.entries(this.cacheData.entries)) {
      const filePath = cacheKey.split(":")[0];
      try {
        const adapter = this.app.vault.adapter;
        const basePath = adapter.path?.absolute || adapter.basePath || process.cwd();
        const fullPath = path2.join(basePath, filePath);
        if (!fs2.existsSync(fullPath)) {
          ghostCount++;
        }
      } catch (error) {
        ghostCount++;
      }
    }
    return ghostCount;
  }
  // Очистка "призрачных" записей из кэша
  async cleanupGhostEntries() {
    this.createBackup();
    const entriesToRemove = [];
    for (const [cacheKey, entry] of Object.entries(this.cacheData.entries)) {
      const filePath = cacheKey.split(":")[0];
      try {
        const adapter = this.app.vault.adapter;
        const basePath = adapter.path?.absolute || adapter.basePath || process.cwd();
        const fullPath = path2.join(basePath, filePath);
        if (!fs2.existsSync(fullPath)) {
          entriesToRemove.push(cacheKey);
        }
      } catch (error) {
        entriesToRemove.push(cacheKey);
      }
    }
    for (const cacheKey of entriesToRemove) {
      delete this.cacheData.entries[cacheKey];
    }
    if (entriesToRemove.length > 0) {
      await this.saveCache();
    }
    return entriesToRemove.length;
  }
};

// main.ts
var ProgressModal = class extends import_obsidian2.Modal {
  constructor(app, title) {
    super(app);
    this.titleEl.setText(title);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("div", { text: "\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439...", cls: "progress-title" });
    this.statusElement = contentEl.createEl("div", {
      text: "\u041F\u043E\u0434\u0433\u043E\u0442\u043E\u0432\u043A\u0430...",
      cls: "progress-status"
    });
    const progressContainer = contentEl.createEl("div", { cls: "progress-container" });
    const progressBar = progressContainer.createEl("div", { cls: "progress-bar" });
    this.progressElement = progressBar.createEl("div", { cls: "progress-fill" });
    this.styleElement = document.createElement("style");
    this.styleElement.textContent = `
			.progress-container {
				width: 100%;
				height: 20px;
				background-color: #e0e0e0;
				border-radius: 10px;
				margin: 10px 0;
				overflow: hidden;
			}
			.progress-bar {
				width: 100%;
				height: 100%;
				position: relative;
			}
			.progress-fill {
				height: 100%;
				background-color: #4caf50;
				transition: width 0.3s ease;
				width: 0%;
			}
			.progress-title {
				font-size: 16px;
				font-weight: bold;
				margin-bottom: 10px;
			}
			.progress-status {
				font-size: 14px;
				color: #666;
				margin-bottom: 10px;
			}
		`;
    document.head.appendChild(this.styleElement);
  }
  updateProgress(current, total, status) {
    const percentage = total > 0 ? current / total * 100 : 0;
    this.progressElement.style.width = `${percentage}%`;
    this.statusElement.setText(`${status} (${current}/${total})`);
  }
  setCompleted(message) {
    this.statusElement.setText(message);
    this.progressElement.style.width = "100%";
    this.progressElement.style.backgroundColor = "#4caf50";
    setTimeout(() => this.close(), 2e3);
  }
  setError(message) {
    this.statusElement.setText(message);
    this.progressElement.style.backgroundColor = "#f44336";
    setTimeout(() => this.close(), 3e3);
  }
  onClose() {
    if (this.styleElement?.parentNode) {
      this.styleElement.parentNode.removeChild(this.styleElement);
    }
  }
};
var TinyLocal = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.AUTO_COMPRESS_DELAY = 3e3;
    this.MIN_FILE_SIZE = 1024;
    // 1KB
    this.SUPPORTED_IMAGE_EXTENSIONS = ["png", "jpg", "jpeg"];
    // Новые настройки для автоматического сжатия
    this.AUTO_BACKGROUND_THRESHOLD = 50; // Будет обновлено после загрузки настроек
    // Запускать при >50 несжатых (настраивается)
    this.USER_INACTIVITY_THRESHOLD = 2 * 60 * 1e3;
    // 2 минуты неактивности
    this.INACTIVITY_CHECK_INTERVAL = 5 * 60 * 1e3;
    // Проверка каждые 5 минут
    this.lastUserActivity = Date.now();
    this.isBackgroundCompressionRunning = false;
    this.inactivityTimer = null;
  }
  // ========================================================================
  // LIFECYCLE METHODS
  // ========================================================================
  async onload() {
    await this.initializePlugin();
    this.setupEventListeners();
    this.registerCommands();
    this.addSettingTab(new SettingsTab(this.app, this));
    await this.setupStatusBar();
  }
  onunload() {
    if (this.inactivityTimer) {
      clearTimeout(this.inactivityTimer);
      this.inactivityTimer = null;
    }
  }
  // ========================================================================
  // INITIALIZATION
  // ========================================================================
  async initializePlugin() {
    await this.loadSettings();
    // Обновляем порог фонового сжатия после загрузки настроек
    this.AUTO_BACKGROUND_THRESHOLD = this.settings.autoBackgroundThreshold || 50;
    this.cache = new Cache(this.app);
    this.compressor = new Compressor(this.getPluginDirectory());
    if (!this.compressor.checkBinaries().pngquant && !this.compressor.checkBinaries().mozjpeg) {
      new import_obsidian2.Notice("TinyLocal: \u0411\u0438\u043D\u0430\u0440\u043D\u0438\u043A\u0438 \u0434\u043B\u044F \u0441\u0436\u0430\u0442\u0438\u044F \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B. \u041F\u043B\u0430\u0433\u0438\u043D \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D.", 8e3);
      throw new Error("Binary files not found");
    }
  }
  getPluginDirectory() {
    const manifestDir = this.manifest.dir;
    const configDir = this.app.vault.configDir;
    const adapter = this.app.vault.adapter;
    const basePath = adapter.path?.absolute || adapter.basePath || process.cwd();
    if (manifestDir) {
      return manifestDir.startsWith("/") || manifestDir.includes(":") ? manifestDir : `${basePath}/${manifestDir}`.replace(/\\/g, "/");
    }
    return `${basePath}/${configDir}/plugins/tiny-local`.replace(/\\/g, "/");
  }
  setupEventListeners() {
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (file instanceof import_obsidian2.TFile) {
          this.addContextMenu(menu, file);
        } else if (file instanceof import_obsidian2.TFolder) {
          this.addFolderContextMenu(menu, file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("create", async (file) => {
        await this.updateStatusBar();
        await this.handleNewFile(file);
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", async () => await this.updateStatusBar())
    );
    this.registerEvent(
      this.app.vault.on("rename", async () => await this.updateStatusBar())
    );
    this.setupUserActivityTracking();
    this.startInactivityCheck();
  }
  // Отслеживание активности пользователя
  setupUserActivityTracking() {
    const updateActivity = () => {
      this.lastUserActivity = Date.now();
    };
    document.addEventListener("mousemove", updateActivity, { passive: true });
    document.addEventListener("keydown", updateActivity, { passive: true });
    document.addEventListener("click", updateActivity, { passive: true });
    document.addEventListener("scroll", updateActivity, { passive: true });
    this.registerEvent(
      this.app.workspace.on("file-open", updateActivity)
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", updateActivity)
    );
  }
  // Проверка неактивности пользователя
  isUserInactive() {
    const timeSinceLastActivity = Date.now() - this.lastUserActivity;
    return timeSinceLastActivity > this.USER_INACTIVITY_THRESHOLD;
  }
  // Запуск проверки неактивности
  startInactivityCheck() {
    const checkInactivity = async () => {
      if (this.settings.autoBackgroundCompression && this.isUserInactive()) {
        await this.checkAndStartBackgroundCompression();
      }
      this.inactivityTimer = setTimeout(checkInactivity, this.INACTIVITY_CHECK_INTERVAL);
    };
    this.inactivityTimer = setTimeout(checkInactivity, this.INACTIVITY_CHECK_INTERVAL);
  }
  // Проверка и запуск фонового сжатия
  async checkAndStartBackgroundCompression() {
    if (!this.isUserInactive()) {
      return;
    }
    const uncompressedCount = await this.getUncompressedImagesCount();
    if (uncompressedCount > this.AUTO_BACKGROUND_THRESHOLD) {
      console.log(`[TinyLocal] \u0410\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u043E\u0435 \u0444\u043E\u043D\u043E\u0432\u043E\u0435 \u0441\u0436\u0430\u0442\u0438\u0435: ${uncompressedCount} \u043D\u0435\u0441\u0436\u0430\u0442\u044B\u0445 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439`);
      await this.startBackgroundCompression();
    }
  }
  // Фоновое сжатие без уведомлений
  async startBackgroundCompression() {
    if (this.isBackgroundCompressionRunning) {
      return;
    }
    this.isBackgroundCompressionRunning = true;
    try {
      const imageFiles = await this.getImageFiles();
      const filteredFiles = imageFiles.filter(
        (file) => this.isImageFile(file) && this.isAllowedPath(file.path)
      );
      const uncompressedFiles = [];
      for (const file of filteredFiles) {
        if (!await this.cache.isFileAlreadyCompressed(file.path)) {
          uncompressedFiles.push(file);
        }
      }
      console.log(`[TinyLocal] \u041D\u0430\u0447\u0438\u043D\u0430\u0435\u043C \u0444\u043E\u043D\u043E\u0432\u043E\u0435 \u0441\u0436\u0430\u0442\u0438\u0435 ${uncompressedFiles.length} \u0444\u0430\u0439\u043B\u043E\u0432`);
      await this.processBatchCompressionBackground(uncompressedFiles);
      console.log("[TinyLocal] \u0424\u043E\u043D\u043E\u0432\u043E\u0435 \u0441\u0436\u0430\u0442\u0438\u0435 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E");
    } catch (error) {
      console.error("[TinyLocal] \u041E\u0448\u0438\u0431\u043A\u0430 \u0444\u043E\u043D\u043E\u0432\u043E\u0433\u043E \u0441\u0436\u0430\u0442\u0438\u044F:", error);
    } finally {
      this.isBackgroundCompressionRunning = false;
      await this.updateStatusBar();
    }
  }
  // Пакетное сжатие в фоне (без модального окна)
  async processBatchCompressionBackground(files) {
    await this.withPluginsDisabled(
      ["obsidian-paste-image-rename"],
      async () => {
        let compressed = 0;
        let processed = 0;
        let skippedAlreadyCompressed = 0;
        let skippedValidation = 0;
        let skippedErrors = 0;
        for (const file of files) {
          try {
            processed++;
            console.log(`[TinyLocal] \u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430: ${file.name} (${processed}/${files.length})`);
            const isAlreadyCompressed = await this.cache.isFileAlreadyCompressed(file.path);
            if (isAlreadyCompressed) {
              console.log(`[TinyLocal] \u041F\u0440\u043E\u043F\u0443\u0449\u0435\u043D (\u0443\u0436\u0435 \u0441\u0436\u0430\u0442): ${file.name}`);
              skippedAlreadyCompressed++;
              continue;
            }
            const validation = await this.validateFileForCompression(file);
            if (!validation.valid) {
              console.log(`[TinyLocal] \u041F\u0440\u043E\u043F\u0443\u0449\u0435\u043D: ${file.name}`);
              skippedValidation++;
              continue;
            }
            const result = await this.compressor.compress(file, this.settings);
            if (result.success) {
              compressed++;
              console.log(`[TinyLocal] \u0421\u0436\u0430\u0442 (${result.savings}%): ${file.name}`);
              const cacheKey = await this.cache.getCacheKey(file);
              // Сохраняем оригинальный размер файла в кэш
              await this.cache.addToCache(cacheKey, file.stat.size);
              await this.updateStatusBar();
            } else {
              console.log(`[TinyLocal] \u041F\u0440\u043E\u043F\u0443\u0449\u0435\u043D: ${file.name}`);
              skippedErrors++;
            }
          } catch (error) {
            console.error(`[TinyLocal] \u041E\u0448\u0438\u0431\u043A\u0430: ${file.name}`, error);
            skippedErrors++;
          }
        }
        console.log(`[TinyLocal] \u0424\u043E\u043D\u043E\u0432\u043E\u0435 \u0441\u0436\u0430\u0442\u0438\u0435 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E: ${compressed} \u0441\u0436\u0430\u0442\u043E, ${skippedAlreadyCompressed} \u043F\u0440\u043E\u043F\u0443\u0449\u0435\u043D\u043E (\u0443\u0436\u0435 \u0441\u0436\u0430\u0442\u044B), ${skippedValidation} \u043F\u0440\u043E\u043F\u0443\u0449\u0435\u043D\u043E (\u0432\u0430\u043B\u0438\u0434\u0430\u0446\u0438\u044F), ${skippedErrors} \u043E\u0448\u0438\u0431\u043E\u043A`);
        if (compressed > 0) {
          this.cache.createBackup();
          // Обновляем индикатор экономии в настройках
          this.updateSavingsIndicatorInSettings();
        }
      }
    );
  }
  async handleNewFile(file) {
    if (!this.settings.autoCompressNewFiles || !(file instanceof import_obsidian2.TFile) || !this.isImageFile(file)) {
      return;
    }
    setTimeout(async () => {
      await this.autoCompressNewFile(file);
    }, this.AUTO_COMPRESS_DELAY);
  }
  async setupStatusBar() {
    this.statusBarItem = this.addStatusBarItem();
    await this.updateStatusBar();
  }
  // ========================================================================
  // SETTINGS MANAGEMENT
  // ========================================================================
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // ========================================================================
  // COMMAND REGISTRATION
  // ========================================================================
  registerCommands() {
    const commands = [
      {
        id: "compress-images-in-note",
        name: "\u0421\u0436\u0430\u0442\u044C \u0432\u0441\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0432 \u0437\u0430\u043C\u0435\u0442\u043A\u0435",
        callback: () => this.compressImagesInNote()
      },
      {
        id: "compress-images-in-folder",
        name: "\u0421\u0436\u0430\u0442\u044C \u0432\u0441\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0432 \u043F\u0430\u043F\u043A\u0435",
        callback: () => this.compressImagesInFolder()
      },
      {
        id: "compress-all-images",
        name: "\u0421\u0436\u0430\u0442\u044C \u0432\u0441\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0432 vault",
        callback: () => this.compressAllImages()
      }
    ];
    commands.forEach((cmd) => this.addCommand(cmd));
  }
  // ========================================================================
  // CONTEXT MENU
  // ========================================================================
  addContextMenu(menu, file) {
    if (!this.isImageFile(file))
      return;
    menu.addItem((item) => {
      item.setTitle("\u0421\u0436\u0430\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435").setIcon("compress").onClick(() => this.compressFile(file));
    });
  }
  addFolderContextMenu(menu, folder) {
    if (folder.path.includes(this.settings.outputFolder))
      return;
    menu.addItem((item) => {
      item.setTitle("\u0421\u0436\u0430\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0432 \u043F\u0430\u043F\u043A\u0435").setIcon("images").onClick(() => this.compressImagesInFolderPath(folder.path));
    });
  }
  // ========================================================================
  // UTILITY METHODS
  // ========================================================================
  isImageFile(file) {
    return this.SUPPORTED_IMAGE_EXTENSIONS.includes(file.extension.toLowerCase());
  }
  async isImageFileAndNotCompressed(file) {
    if (!this.isImageFile(file)) {
      return false;
    }
    const pathParts = file.path.split("/");
    const isInOutputFolder = pathParts.includes(this.settings.outputFolder);
    if (isInOutputFolder) {
      return false;
    }
    const isAlreadyCompressed = await this.cache.isFileAlreadyCompressed(file.path);
    return !isAlreadyCompressed;
  }
  // Получаем ВСЕ изображения (без проверки кэша, как в старой версии)
  getAllImageFiles() {
    const allFiles = this.app.vault.getFiles();
    const imageFiles = [];
    for (const file of allFiles) {
      if (this.isImageFile(file)) {
        const pathParts = file.path.split("/");
        const isInOutputFolder = pathParts.includes(this.settings.outputFolder);
        if (!isInOutputFolder) {
          imageFiles.push(file);
        }
      }
    }
    return imageFiles;
  }
  async getImageFiles() {
    const allFiles = this.app.vault.getFiles();
    const imageFiles = [];
    for (const file of allFiles) {
      if (await this.isImageFileAndNotCompressed(file)) {
        imageFiles.push(file);
      }
    }
    return imageFiles;
  }
  isAllowedPath(filePath) {
    if (!this.settings.allowedRoots?.length) {
      return true;
    }
    const isAllowed = this.settings.allowedRoots.some((root) => filePath.startsWith(root));
    return isAllowed;
  }
  // ========================================================================
  // PLUGIN DISABLE/ENABLE UTILITY
  // ========================================================================
  async withPluginsDisabled(pluginIds, task) {
    const disabled = [];
    try {
      for (const id of pluginIds) {
        if (this.app.plugins?.enabledPlugins?.has(id)) {
          await this.app.plugins.disablePlugin(id);
          disabled.push(id);
        }
      }
      return await task();
    } finally {
      for (const id of disabled) {
        try {
          await this.app.plugins.enablePlugin(id);
        } catch (error) {
        }
      }
    }
  }
  // ========================================================================
  // VALIDATION
  // ========================================================================
  async validateFileForCompression(file) {
    if (!this.isAllowedPath(file.path)) {
      return { valid: false, error: "\u041F\u0443\u0442\u044C \u043D\u0435 \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043D \u0432 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u0445" };
    }
    const isAlreadyCompressed = await this.cache.isFileAlreadyCompressed(file.path);
    if (isAlreadyCompressed) {
      return { valid: false, error: "\u0424\u0430\u0439\u043B \u0443\u0436\u0435 \u0441\u0436\u0430\u0442" };
    }
    const minSize = file.extension.toLowerCase() === "png" ? 5 * 1024 : 10 * 1024;
    if (file.stat.size < minSize) {
      await this.cache.addSkippedEntry(file.path, "too_small");
      return { valid: false, error: `\u0424\u0430\u0439\u043B \u0441\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u0438\u0439 (${file.stat.size} \u0431\u0430\u0439\u0442)`, skipped: true };
    }
    return { valid: true };
  }
  // ========================================================================
  // COMPRESSION METHODS
  // ========================================================================
  async compressFile(file) {
    await this.withPluginsDisabled(
      ["obsidian-paste-image-rename"],
      async () => {
        try {
          const validation = await this.validateFileForCompression(file);
          if (!validation.valid) {
            if (validation.skipped) {
              return;
            } else {
              new import_obsidian2.Notice(`TinyLocal: ${validation.error}`);
              return;
            }
          }
          const result = await this.compressor.compress(file, this.settings);
          if (result.success) {
            await this.handleSuccessfulCompression(file, result.savings);
          } else {
            new import_obsidian2.Notice(`TinyLocal: \u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u0436\u0430\u0442\u0438\u044F: ${result.error}`);
          }
        } catch (error) {
          new import_obsidian2.Notice("TinyLocal: \u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0441\u0436\u0430\u0442\u0438\u0438 \u0444\u0430\u0439\u043B\u0430");
        }
      }
    );
  }
  async handleSuccessfulCompression(file, savings) {
    const cacheKey = await this.cache.getCacheKey(file);
    // Сохраняем оригинальный размер файла в кэш
    await this.cache.addToCache(cacheKey, file.stat.size);
    this.cache.createBackup();
    await this.updateStatusBar();
    
    // Обновляем индикатор экономии в настройках, если они открыты
    this.updateSavingsIndicatorInSettings();
    
    if (savings) {
      new import_obsidian2.Notice(`TinyLocal: \u0424\u0430\u0439\u043B \u0441\u0436\u0430\u0442, \u044D\u043A\u043E\u043D\u043E\u043C\u0438\u044F ${Math.round(savings)}%`);
    } else {
      new import_obsidian2.Notice("TinyLocal: \u0424\u0430\u0439\u043B \u0441\u0436\u0430\u0442");
    }
  }
  async autoCompressNewFile(file) {
    await this.withPluginsDisabled(
      ["obsidian-paste-image-rename"],
      async () => {
        try {
          const validation = await this.validateFileForCompression(file);
          if (!validation.valid)
            return;
          const result = await this.compressor.compress(file, this.settings);
          if (result.success) {
            await this.handleSuccessfulCompression(file, result.savings);
          }
        } catch (error) {
        }
      }
    );
  }
  // ========================================================================
  // BATCH COMPRESSION METHODS
  // ========================================================================
  async compressImagesInNote() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian2.Notice("TinyLocal: \u041D\u0435\u0442 \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0439 \u0437\u0430\u043C\u0435\u0442\u043A\u0438");
      return;
    }
    const images = await this.getImagesInNote(activeFile);
    if (images.length === 0) {
      new import_obsidian2.Notice("TinyLocal: \u0412 \u0437\u0430\u043C\u0435\u0442\u043A\u0435 \u043D\u0435\u0442 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439");
      return;
    }
    await this.processBatchCompression(images, "TinyLocal: \u0421\u0436\u0430\u0442\u0438\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439 \u0432 \u0437\u0430\u043C\u0435\u0442\u043A\u0435");
  }
  async compressImagesInFolder() {
    const folders = this.app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian2.TFolder);
    if (folders.length === 0) {
      new import_obsidian2.Notice("TinyLocal: \u0412 vault \u043D\u0435\u0442 \u043F\u0430\u043F\u043E\u043A");
      return;
    }
    const folderPaths = folders.map((folder) => folder.path).filter((path4) => path4 !== "");
    folderPaths.unshift("/");
    const selectedPath = await this.showFolderSelector(folderPaths);
    if (selectedPath === null)
      return;
    await this.compressImagesInFolderPath(selectedPath);
  }
  async compressAllImages() {
    await this.compressImagesInFolderPath("/", true);
  }
  async processBatchCompression(files, title) {
    await this.withPluginsDisabled(
      ["obsidian-paste-image-rename"],
      async () => {
        const progressModal = new ProgressModal(this.app, title);
        progressModal.open();
        progressModal.updateProgress(0, files.length, "\u041D\u0430\u0447\u0438\u043D\u0430\u0435\u043C \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0443...");
        let compressed = 0;
        let processed = 0;
        let skippedAlreadyCompressed = 0;
        let skippedValidation = 0;
        let skippedErrors = 0;
        for (const file of files) {
          try {
            processed++;
            progressModal.updateProgress(processed, files.length, `\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430: ${file.name}`);
            const isAlreadyCompressed = await this.cache.isFileAlreadyCompressed(file.path);
            if (isAlreadyCompressed) {
              progressModal.updateProgress(processed, files.length, `\u041F\u0440\u043E\u043F\u0443\u0449\u0435\u043D (\u0443\u0436\u0435 \u0441\u0436\u0430\u0442): ${file.name}`);
              skippedAlreadyCompressed++;
              continue;
            }
            const validation = await this.validateFileForCompression(file);
            if (!validation.valid) {
              progressModal.updateProgress(processed, files.length, `\u041F\u0440\u043E\u043F\u0443\u0449\u0435\u043D: ${file.name}`);
              skippedValidation++;
              continue;
            }
            const result = await this.compressor.compress(file, this.settings);
            if (result.success) {
              compressed++;
              progressModal.updateProgress(processed, files.length, `\u0421\u0436\u0430\u0442 (${result.savings}%): ${file.name}`);
              const cacheKey = await this.cache.getCacheKey(file);
              // Сохраняем оригинальный размер файла в кэш
              await this.cache.addToCache(cacheKey, file.stat.size);
            } else {
              progressModal.updateProgress(processed, files.length, `\u041F\u0440\u043E\u043F\u0443\u0449\u0435\u043D: ${file.name}`);
              skippedErrors++;
            }
          } catch (error) {
            progressModal.updateProgress(processed, files.length, `\u041E\u0448\u0438\u0431\u043A\u0430: ${file.name}`);
            skippedErrors++;
          }
        }
        progressModal.setCompleted(`\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E! \u0421\u0436\u0430\u0442\u043E ${compressed} \u0438\u0437 ${files.length} \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439`);
        if (compressed > 0) {
          this.cache.createBackup();
          // Обновляем индикатор экономии в настройках
          this.updateSavingsIndicatorInSettings();
        }
      }
    );
    await this.updateStatusBar();
  }
  // ========================================================================
  // FOLDER SELECTION
  // ========================================================================
  async showFolderSelector(folderPaths) {
    return new Promise((resolve2) => {
      const modal = document.createElement("div");
      modal.className = "modal-container";
      modal.innerHTML = `
				<div class="modal">
					<div class="modal-header">
						<h3>\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u043F\u0430\u043F\u043A\u0443 \u0434\u043B\u044F \u0441\u0436\u0430\u0442\u0438\u044F \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439</h3>
					</div>
					<div class="modal-content">
						<select id="folder-select" style="width: 100%; padding: 8px; margin: 10px 0;">
							${folderPaths.map(
        (path4) => `<option value="${path4}">${path4 === "/" ? "\u041A\u043E\u0440\u043D\u0435\u0432\u0430\u044F \u043F\u0430\u043F\u043A\u0430" : path4}</option>`
      ).join("")}
						</select>
					</div>
					<div class="modal-footer">
						<button id="select-folder" class="mod-cta">\u0412\u044B\u0431\u0440\u0430\u0442\u044C</button>
						<button id="cancel-folder">\u041E\u0442\u043C\u0435\u043D\u0430</button>
					</div>
				</div>
			`;
      document.body.appendChild(modal);
      const selectBtn = modal.querySelector("#select-folder");
      const cancelBtn = modal.querySelector("#cancel-folder");
      const select = modal.querySelector("#folder-select");
      const cleanup = () => {
        if (document.body.contains(modal)) {
          document.body.removeChild(modal);
        }
      };
      selectBtn?.addEventListener("click", () => {
        resolve2(select.value);
        cleanup();
      });
      cancelBtn?.addEventListener("click", () => {
        resolve2(null);
        cleanup();
      });
      modal.addEventListener("click", (e) => {
        if (e.target === modal) {
          resolve2(null);
          cleanup();
        }
      });
    });
  }
  async compressImagesInFolderPath(folderPath, isRecursive = false) {
    const allFiles = this.app.vault.getFiles();
    let targetFiles;
    if (folderPath === "/") {
      targetFiles = allFiles;
    } else {
      targetFiles = allFiles.filter((file) => {
        if (isRecursive) {
          return file.path.startsWith(folderPath + "/") || file.path.startsWith(folderPath);
        } else {
          const fileFolderPath = file.path.substring(0, file.path.lastIndexOf("/"));
          return fileFolderPath === folderPath;
        }
      });
    }
    const imageFiles = [];
    for (const file of targetFiles) {
      if (await this.isImageFileAndNotCompressed(file)) {
        imageFiles.push(file);
      }
    }
    if (imageFiles.length === 0) {
      new import_obsidian2.Notice(`TinyLocal: \u0412 \u043F\u0430\u043F\u043A\u0435 "${folderPath}" \u043D\u0435\u0442 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439 \u0434\u043B\u044F \u0441\u0436\u0430\u0442\u0438\u044F`);
      return;
    }
    await this.processBatchCompression(imageFiles, "TinyLocal: \u0421\u0436\u0430\u0442\u0438\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439");
  }
  // ========================================================================
  // IMAGE DETECTION
  // ========================================================================
  async getImagesInNote(file) {
    try {
      const content = await this.app.vault.read(file);
      const imageRegex = /!\[\[([^\]]+\.(png|jpg|jpeg|gif|bmp|webp))\]\]/gi;
      const matches = content.match(imageRegex);
      if (!matches)
        return [];
      const imageFiles = [];
      const allFiles = this.app.vault.getFiles();
      for (const match of matches) {
        const fileName = match.replace(/!\[\[([^\]]+)\]\]/g, "$1");
        const imageFile = this.app.vault.getAbstractFileByPath(fileName);
        if (imageFile instanceof import_obsidian2.TFile && this.isImageFile(imageFile)) {
          imageFiles.push(imageFile);
          continue;
        }
        const foundFile = allFiles.find(
          (f) => f.name === fileName || f.path.endsWith(fileName) || f.path.endsWith("/" + fileName)
        );
        if (foundFile && this.isImageFile(foundFile)) {
          imageFiles.push(foundFile);
        }
      }
      return imageFiles;
    } catch (error) {
      return [];
    }
  }
  // ========================================================================
  // STATISTICS
  // ========================================================================
  async getTotalImagesCount() {
    const imageFiles = this.getAllImageFiles();
    return imageFiles.length;
  }
  async getUncompressedImagesCount() {
    const imageFiles = this.getAllImageFiles();
    let count = 0;
    for (const file of imageFiles) {
      if (!await this.cache.isFileAlreadyCompressed(file.path)) {
        count++;
      }
    }
    return count;
  }
  
  // ========================================================================
  // SPACE SAVINGS CALCULATION
  // ========================================================================
  
  // Константы для размеров файлов
  static FILE_SIZE_THRESHOLDS = {
    KB_100: 100 * 1024,
    KB_200: 200 * 1024,
    KB_500: 500 * 1024,
    MB_1: 1024 * 1024
  };
  
  // Константы для коэффициентов сжатия
  static COMPRESSION_RATIOS = {
    PNG_SMALL: 2.5,    // < 100KB: 60% сжатие
    PNG_MEDIUM: 2.0,   // 100KB - 1MB: 50% сжатие
    PNG_LARGE: 1.8,    // > 1MB: 45% сжатие
    JPEG_SMALL: 1.4,   // < 500KB: 70% сжатие
    JPEG_LARGE: 1.3,   // > 500KB: 75% сжатие
    WEBP_SMALL: 2.0,   // < 200KB: 50% сжатие
    WEBP_LARGE: 1.7,   // > 200KB: 60% сжатие
    DEFAULT: 1.5       // Средний коэффициент для других форматов
  };
  async calculateSpaceSavings() {
    try {
      const allFiles = this.getAllImageFiles();
      if (allFiles.length === 0) {
        return this.getEmptySavingsResult();
      }

      let originalSize = 0;
      let currentSize = 0;
      let processedFiles = 0;
      let filesWithExactData = 0;
      let estimatedFiles = 0;
      
      // Обрабатываем файлы пакетами для лучшей производительности
      const batchSize = 50;
      for (let i = 0; i < allFiles.length; i += batchSize) {
        const batch = allFiles.slice(i, i + batchSize);
        
        for (const file of batch) {
          const fileSize = file.stat.size;
          const isCompressed = await this.cache.isFileAlreadyCompressed(file.path);
          
          if (isCompressed) {
            // Для сжатых файлов используем сохраненный оригинальный размер из кэша
            const cachedOriginalSize = await this.getCachedOriginalSize(file.path);
            if (cachedOriginalSize && cachedOriginalSize > fileSize) {
              // Только если у нас есть точные данные И оригинал больше текущего
              originalSize += cachedOriginalSize;
              currentSize += fileSize;
              filesWithExactData++;
            } else {
              // Если нет точных данных, оцениваем оригинальный размер
              const estimatedOriginalSize = this.estimateOriginalSizeFromCurrent(file);
              originalSize += estimatedOriginalSize;
              currentSize += fileSize;
              estimatedFiles++;
            }
            processedFiles++; // Считаем все файлы в кэше как обработанные
          } else {
            // Для несжатых файлов считаем только оригинальный размер
            originalSize += fileSize;
            currentSize += fileSize;
          }
        }
        
        // Небольшая пауза между пакетами для предотвращения блокировки UI
        if (i + batchSize < allFiles.length) {
          await new Promise(resolve => setTimeout(resolve, 1));
        }
      }
      
      // Показываем статистику если есть файлы с точными данными ИЛИ оцененными
      if (filesWithExactData === 0 && estimatedFiles === 0) {
        return this.getEmptySavingsResult(allFiles.length);
      }
      
      const savedSize = Math.max(0, originalSize - currentSize);
      const savedPercentage = originalSize > 0 ? Math.round((savedSize / originalSize) * 100) : 0;
      
      return {
        originalSize,
        currentSize,
        savedSize,
        savedPercentage,
        processedFiles,
        totalFiles: allFiles.length,
        estimatedFiles
      };
    } catch (error) {
      console.error("[TinyLocal] Ошибка расчета экономии места:", error);
      return this.getEmptySavingsResult();
    }
  }

  getEmptySavingsResult(totalFiles = 0) {
    return {
      originalSize: 0,
      currentSize: 0,
      savedSize: 0,
      savedPercentage: 0,
      processedFiles: 0,
      totalFiles,
      estimatedFiles: 0
    };
  }

  validateSavingsData(savings) {
    return savings && 
           typeof savings.processedFiles === 'number' && 
           typeof savings.savedSize === 'number' && 
           typeof savings.originalSize === 'number' &&
           typeof savings.currentSize === 'number' &&
           typeof savings.savedPercentage === 'number' &&
           typeof savings.totalFiles === 'number' &&
           typeof savings.estimatedFiles === 'number' &&
           savings.processedFiles > 0 && 
           savings.savedSize > 0 &&
           savings.originalSize >= 0 &&
           savings.currentSize >= 0 &&
           savings.savedPercentage >= 0 &&
           savings.totalFiles >= 0 &&
           savings.estimatedFiles >= 0;
  }

  estimateOriginalSizeFromCurrent(file) {
    try {
      if (!file || !file.stat || typeof file.stat.size !== 'number') {
        return 0;
      }
      
      const currentSize = file.stat.size;
      const extension = (file.extension || '').toLowerCase();
      
      // Получаем коэффициент сжатия на основе формата и размера
      const compressionRatio = this.getCompressionRatio(extension, currentSize, TinyLocal.FILE_SIZE_THRESHOLDS);
      
      const estimatedSize = Math.round(currentSize * compressionRatio);
      
      // Защита от нереалистичных значений
      if (estimatedSize <= 0 || estimatedSize > currentSize * 10) {
        return currentSize; // Возвращаем текущий размер как fallback
      }
      
      return estimatedSize;
    } catch (error) {
      console.error("[TinyLocal] Ошибка оценки оригинального размера:", error);
      return file.stat.size; // Возвращаем текущий размер как fallback
    }
  }

  getCompressionRatio(extension, currentSize, sizes) {
    const { KB_100, KB_200, KB_500, MB_1 } = sizes;
    const ratios = TinyLocal.COMPRESSION_RATIOS;
    
    switch (extension) {
      case 'png':
        if (currentSize < KB_100) return ratios.PNG_SMALL;
        if (currentSize < MB_1) return ratios.PNG_MEDIUM;
        return ratios.PNG_LARGE;
        
      case 'jpg':
      case 'jpeg':
        if (currentSize < KB_500) return ratios.JPEG_SMALL;
        return ratios.JPEG_LARGE;
        
      case 'webp':
        if (currentSize < KB_200) return ratios.WEBP_SMALL;
        return ratios.WEBP_LARGE;
        
      default:
        return ratios.DEFAULT;
    }
  }

  formatTooltipData(savings) {
    if (!savings) {
      return {
        originalFormatted: '0 B',
        currentFormatted: '0 B',
        savedFormatted: '0 B',
        estimatedIndicator: '',
        estimatedText: ''
      };
    }
    
    const originalFormatted = this.formatFileSize(savings.originalSize || 0);
    const currentFormatted = this.formatFileSize(savings.currentSize || 0);
    const savedFormatted = this.formatFileSize(savings.savedSize || 0);
    const estimatedIndicator = (savings.estimatedFiles || 0) > 0 ? ' ~' : '';
    const estimatedText = (savings.estimatedFiles || 0) > 0 ? ` (${savings.estimatedFiles} оценено)` : '';
    
    return {
      originalFormatted,
      currentFormatted,
      savedFormatted,
      estimatedIndicator,
      estimatedText
    };
  }
  
  async getCachedOriginalSize(filePath) {
    try {
      if (!filePath || !this.cache || !this.cache.cacheData || !this.cache.cacheData.entries) {
        return null;
      }
      
      // Ищем оригинальный размер в кэше
      const entries = this.cache.cacheData.entries;
      const cacheKeys = Object.keys(entries);
      
      // Используем более эффективный поиск
      for (const cacheKey of cacheKeys) {
        const keyPath = cacheKey.split(":")[0];
        if (keyPath === filePath) {
          const entry = entries[cacheKey];
          if (entry && entry.originalSize && typeof entry.originalSize === 'number' && entry.originalSize > 0) {
            return entry.originalSize;
          }
        }
      }
      return null;
    } catch (error) {
      console.error("[TinyLocal] Ошибка получения оригинального размера из кэша:", error);
      return null;
    }
  }
  

  
  getCompressedFilePath(originalPath) {
    const filename = path3.basename(originalPath);
    const adapter = this.app.vault.adapter;
    const basePath = adapter.path?.absolute || adapter.basePath || process.cwd();
    return path3.join(basePath, this.settings.outputFolder, filename);
  }
  
  async getCompressedFileSize(compressedFilePath) {
    try {
      const fs = require('fs');
      if (fs.existsSync(compressedFilePath)) {
        const stats = fs.statSync(compressedFilePath);
        return stats.size;
      }
      return 0;
    } catch (error) {
      return 0;
    }
  }
  
  formatFileSize(bytes) {
    if (bytes === 0) return '0 B';
    
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
  }
  
  shouldShowSavingsIndicator() {
    // Показываем индикатор только если есть сжатые файлы с точными данными
    return this.cache.getCacheStats().total > 0;
  }
  
  async hasValidSavingsData() {
    // Проверяем, есть ли файлы с точными данными о сжатии
    try {
      const savings = await this.calculateSpaceSavings();
      return savings.processedFiles > 0 && savings.savedSize > 0;
    } catch (error) {
      return false;
    }
  }
  
  async updateSavingsIndicator() {
    // Этот метод будет вызываться для обновления индикатора в настройках
    // Реализация будет в SettingsTab
    const savings = await this.calculateSpaceSavings();
    return savings;
  }
  
  updateSavingsIndicatorInSettings() {
    // Обновляем индикатор экономии в настройках
    try {
      const settingsTab = this.app.setting.openTabById('tiny-local');
      if (settingsTab && settingsTab.plugin === this) {
        // Используем requestAnimationFrame для более плавного обновления
        requestAnimationFrame(() => {
          settingsTab.display();
        });
      }
    } catch (error) {
      console.error("[TinyLocal] Ошибка обновления индикатора в настройках:", error);
    }
  }
  // Метод для принудительного обновления кэша и статус-бара
  async forceRefreshCache() {
    await this.cache.forceRefreshCache();
    await this.updateStatusBar();
  }
  // Получение количества призрачных записей в кэше
  async getGhostEntriesCount() {
    return await this.cache.getGhostEntriesCount();
  }
  // Очистка призрачных записей из кэша
  async cleanupGhostEntries() {
    const removedCount = await this.cache.cleanupGhostEntries();
    await this.updateStatusBar();
    return removedCount;
  }
  // ========================================================================
  // STATUS BAR
  // ========================================================================
  async updateStatusBar() {
    if (!this.statusBarItem) {
      return;
    }
    const [uncompressedCount, totalCount] = await Promise.all([
      this.getUncompressedImagesCount(),
      this.getTotalImagesCount()
    ]);
    if (totalCount > 0) {
      const statusText = this.isBackgroundCompressionRunning ? `${uncompressedCount} / ${totalCount} \u25CF` : `${uncompressedCount} / ${totalCount}`;
      this.statusBarItem.setText(statusText);
      this.statusBarItem.show();
      if (this.isBackgroundCompressionRunning) {
        this.statusBarItem.addClass("tiny-local-compressing");
      } else {
        this.statusBarItem.removeClass("tiny-local-compressing");
      }
      this.statusBarItem.onclick = async (event) => {
        event.preventDefault();
        await this.showStatusBarMenu(event);
      };
    } else {
      this.statusBarItem.hide();
    }
  }
  async showStatusBarMenu(event) {
    const [uncompressedCount, totalCount] = await Promise.all([
      this.getUncompressedImagesCount(),
      this.getTotalImagesCount()
    ]);
    const menu = this.createStatusBarMenu(event, uncompressedCount, totalCount);
    document.body.appendChild(menu);
    this.setupMenuEventListeners(menu);
  }
  createStatusBarMenu(event, uncompressedCount, totalCount) {
    const menu = document.createElement("div");
    menu.className = "menu";
    menu.style.cssText = `
			position: fixed;
			z-index: 1000;
			background: var(--background-secondary);
			border: 1px solid var(--background-modifier-border);
			border-radius: 6px;
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
			padding: 4px 0;
			min-width: 200px;
			font-size: 14px;
			color: var(--text-normal);
		`;
    const rect = event.target.getBoundingClientRect();
    const menuWidth = 200;
    const windowWidth = window.innerWidth;
    let left = rect.left;
    if (left + menuWidth > windowWidth) {
      left = windowWidth - menuWidth - 10;
    }
    menu.style.left = `${left}px`;
    menu.style.top = `${rect.top - 10}px`;
    menu.style.transform = "translateY(-100%)";
    const header = menu.createEl("div", {
      text: `\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F: ${uncompressedCount} / ${totalCount}`
    });
    header.style.cssText = `
			padding: 6px 12px;
			font-size: 12px;
			color: var(--text-muted);
			border-bottom: 1px solid var(--background-modifier-border);
			font-weight: 500;
		`;
    const menuItems = [
      { text: "\u0421\u0436\u0430\u0442\u044C \u0432\u0441\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0432 \u0437\u0430\u043C\u0435\u0442\u043A\u0435", action: () => this.compressImagesInNote() },
      { text: "\u0421\u0436\u0430\u0442\u044C \u0432\u0441\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0432 vault", action: () => this.compressAllImages() }
    ];
    menuItems.forEach((item) => {
      const menuItem = menu.createEl("div", { text: item.text });
      menuItem.style.cssText = `
				padding: 6px 12px;
				cursor: pointer;
				user-select: none;
			`;
      menuItem.addEventListener("mouseenter", () => {
        menuItem.style.backgroundColor = "var(--background-modifier-hover)";
      });
      menuItem.addEventListener("mouseleave", () => {
        menuItem.style.backgroundColor = "";
      });
      menuItem.addEventListener("click", () => {
        item.action();
        if (document.body.contains(menu)) {
          document.body.removeChild(menu);
        }
      });
    });
    return menu;
  }
  setupMenuEventListeners(menu) {
    const closeMenu = (e) => {
      if (!menu.contains(e.target)) {
        if (document.body.contains(menu)) {
          document.body.removeChild(menu);
        }
        document.removeEventListener("click", closeMenu);
      }
    };
    setTimeout(() => {
      document.addEventListener("click", closeMenu);
    }, 100);
  }
  // ========================================================================
  // BACKUP MANAGEMENT
  // ========================================================================
  async openBackupsFolder() {
    try {
      const pluginDir = this.getPluginDirectory();
      const backupDir = path3.join(pluginDir, "cache-backups");
      if (!fs3.existsSync(backupDir)) {
        fs3.mkdirSync(backupDir, { recursive: true });
        new import_obsidian2.Notice("TinyLocal: \u0421\u043E\u0437\u0434\u0430\u043D\u0430 \u043F\u0430\u043F\u043A\u0430 \u0434\u043B\u044F \u0431\u0435\u043A\u0430\u043F\u043E\u0432. \u0411\u0435\u043A\u0430\u043F\u044B \u0431\u0443\u0434\u0443\u0442 \u0441\u043E\u0437\u0434\u0430\u0432\u0430\u0442\u044C\u0441\u044F \u043F\u043E\u0441\u043B\u0435 \u043C\u0430\u0441\u0441\u043E\u0432\u043E\u0433\u043E \u0441\u0436\u0430\u0442\u0438\u044F.");
        return;
      }
      const backups = this.cache.getAvailableBackups();
      if (backups.length === 0) {
        new import_obsidian2.Notice("TinyLocal: \u0411\u0435\u043A\u0430\u043F\u044B \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B. \u0421\u043E\u0437\u0434\u0430\u0439\u0442\u0435 \u0431\u0435\u043A\u0430\u043F, \u0441\u0436\u0430\u0432 \u043D\u0435\u0441\u043A\u043E\u043B\u044C\u043A\u043E \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439.");
        return;
      }
      const backupInfo = backups.map((backup) => {
        const backupPath = path3.join(backupDir, backup);
        const stats = fs3.statSync(backupPath);
        const size = (stats.size / 1024).toFixed(1);
        const date = stats.mtime.toLocaleString("ru-RU");
        return `${backup} (${size} \u041A\u0411, ${date})`;
      }).join("\n");
      this.showBackupModal(backupDir, backups, backupInfo);
    } catch (error) {
      new import_obsidian2.Notice("TinyLocal: \u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0442\u043A\u0440\u044B\u0442\u0438\u0438 \u043F\u0430\u043F\u043A\u0438 \u0441 \u0431\u0435\u043A\u0430\u043F\u0430\u043C\u0438");
    }
  }
  showBackupModal(backupDir, backups, backupInfo) {
    const modal = new class extends import_obsidian2.Modal {
      onOpen() {
        const { contentEl } = this;
        contentEl.createEl("h2", { text: "TinyLocal: \u041F\u0430\u043F\u043A\u0430 \u0441 \u0431\u0435\u043A\u0430\u043F\u0430\u043C\u0438" });
        contentEl.createEl("p", { text: `\u041F\u0443\u0442\u044C: ${backupDir}` });
        contentEl.createEl("p", { text: `\u041D\u0430\u0439\u0434\u0435\u043D\u043E \u0431\u0435\u043A\u0430\u043F\u043E\u0432: ${backups.length}` });
        contentEl.createEl("h3", { text: "\u0421\u043F\u0438\u0441\u043E\u043A \u0431\u0435\u043A\u0430\u043F\u043E\u0432:" });
        const list = contentEl.createEl("div");
        list.style.cssText = `
					max-height: 300px;
					overflow-y: auto;
					border: 1px solid var(--background-modifier-border);
					padding: 10px;
					border-radius: 4px;
					font-family: monospace;
					font-size: 12px;
					background: var(--background-secondary);
				`;
        backupInfo.split("\n").forEach((line) => {
          list.createEl("div", { text: line });
        });
        const openButton = contentEl.createEl("button", {
          text: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u043F\u0430\u043F\u043A\u0443 \u0432 \u043F\u0440\u043E\u0432\u043E\u0434\u043D\u0438\u043A\u0435",
          cls: "mod-cta"
        });
        openButton.addEventListener("click", () => {
          const { exec } = require("child_process");
          exec(`explorer "${backupDir}"`, (error) => {
            if (error) {
              new import_obsidian2.Notice("TinyLocal: \u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0442\u043A\u0440\u044B\u0442\u044C \u043F\u0430\u043F\u043A\u0443 \u0432 \u043F\u0440\u043E\u0432\u043E\u0434\u043D\u0438\u043A\u0435");
            }
          });
        });
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    }(this.app);
    modal.open();
  }
};
